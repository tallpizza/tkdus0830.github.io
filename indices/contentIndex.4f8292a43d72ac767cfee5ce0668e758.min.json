{"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3":{"title":"네트워크","content":"\n# [네트워크 주소체계 1 자료](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_09_01.pdf)\n\n**1. IPv6의 주요 변경 사항**\n\n* 주소 공간 확장 : 공간이 32비트에서 128비트로 확장\n* 헤더 구조 단순화 : 오류제어 등의 오버헤드를 줄여 프로토콜의 전송 효율 향상\n* 흐름 제어 기능 지원 : 일정 범위 내에서 예측 가능한 데이터 흐름을 지원 실시간 멀티미디어 응용 환경을 수용 \n\n**2. ﻿확장 헤더의 종류**\n\n* Hop-by-Hop Options Header(Jumbo 페이로드 옵션, 라우터 긴급 옵션)\n* Routing Header, Fragment Header, Destination Options Header, Authentication Header, Encapsulating Security Payload Header, DS/ECN 필드, Flow Label 필드 \n\n**3. ﻿기타 필드**\n\n* Version Number, Payload Length, Next Header, Hop Limit, Source Address/Destination Address \n\n**4. ﻿터널링 원리**\n\n* IP 프로토콜을 교체하는 방식(버스→배→버스) \n\n**5. ﻿IP 터널링**\n\n* 무선 호스트가 움직일 때 이동 IP 프로토콜의 기본 동작 원리\n* 이동 호스트의 움직이면 새로운 위치를 관장하는 포린 에이전트Foreign Agent Fanew 로부터 COACare of Address를 얻음\n* 이 주소는 이동 호스트의 홈 에이전트Home Agent HA에 등록되어 FAnew와 HA 사이에 터널을 형성\n* HA로 라우팅된 패킷을 이동 호스트에 전달하려면 새로 형성된 터널을 통해 FAnew로 전달\n* 이동 호스트에는 고유 IP 주소인 홈 주소Home Addres HA가 할당, 호스트 위치가 바뀌어도 변하지 않음. 홈 에이전트와 밀접한 관련.\n* COA는 이동 호스트가 새로 이동한 지역에서 일시적으로 할당된 IP 주소 호스트가 이동할 때마다 새로운 COA가 할당되고 기존 COA는 회수되는 과정이 반복됨. \n\n**6. ﻿ARP 프로토콜**\n\n* IP 주소와 MAC 주소 사이의 변환을 담당.\n* MAC 주소\n* 송신 호스트의 IP 주소 : 송신 호스트의 하드 디스크에서 얻을 수 있음.\n* 수신 호스트의 IP 주소 : 사용자가 제공\n* 송신 호스트의 MAC 주소 : 송신 호스트의 LAN 카드에서 얻을 수 있음.\n* 수신 호스트의 MAC 주소 : IP 주소를 매개변수로 하여 ARP 프로토콜로 얻음. \n\n**7. ﻿RARPReverse Address Resolution Protocol 프로토콜의 필요성**  \n하드 디스크가 없는 시스템은 자신의 IP 주소를 알 수 없음.  \n특정 호스트의 MAC 주소로 부터 IP 주소를 제공하는 프로토콜\n\n문제  \n01\n\nIPv4에서 IPv6로의 변경에서 주요 변경 사항이 아닌 것은?\n\n32비트에서 128비트로 확장되었다.\n\n오류제어 등의 오버헤드를 출여 프로토콜의 전송 효율이 향상되었다.\n\n일정 범위 내에서 예측 가능한 데이터 흐름을 지원하여 실시간 멀티미디어 응용 환경을 수용할 수 있다.\n\n주소 공간이 축소되면서 헤더 구조를 단순화하였다.\n\n4\n\n주소 공간의 확장과 헤더 구조를 단순화하였다.\n\n문제  \n02\n\nIPv6의 확장 헤더가 아닌 것은?\n\nRouting Header\n\nFragment Header\n\nAuthentication Header\n\n==Extension Label 필드 ===\n\n문제  \n03\n\nARP 포르토콜에 대한 설명 중 잘못된 것은?\n\n특정 호스트의 IP 주소로부터 MAC 주소를 제공하는 프로토콜이다.\n\n==ACK Message라는 특수 패킷을 브로드캐스팅 한다.==\n\nIP 주소에 해당하는 호스트만 ARP reply로 MAC 주소를 회신한다.\n\n효율 향상을 위해 캐시 기능을 제공한다.\n\n# [네트워크 계층 자료](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_09_02.pdf)\n\n문제  \n01\n\n다음 중 ICMP 오류 보고 메시지가 아닌 것은?\n\nDestination unreachable\n\nSource quench\n\nTime exceeded\n\nSource unreachable\n\n4\n\nICMP 오류 보고 메시지는 Destination unreachable, Source quench, Time exceeded이다. Source unreachable는 존재하지 않는 메시지이다.\n\n문제  \n02\n\nIGMP 프로토콜의 그룹 관리의 주요 기능으로 잘못된 것은?\n\n그룹의 생성 및 제거\n\n그룹의 수정\n\n전송 호스트의 그룹 참가\n\n전송 호스트의 그룹 탈퇴\n\n2\n\n그룹 관리의 주요 기능으로는 그룹의 생성 및 제거, 전송 호스트의 그룹 참가 및 탈퇴 등이 있다.\n\n문제  \n03\n\nIGMP 메시지 전송에 대한 설명 중 바르게 설명한 것은?\n\nIP 패킷에 캡슐화 되어 전송된다.\n\nTCP 헤더와 함께 캡슐화 되어 전송된다.\n\nUDP 헤더와 함께 캡슐화 되어 전송된다.\n\nIGMP 단독 메시지 형태로 전송된다.\n\n1\n\nIGMP는 IP 패킷에 캡슐화 되어 전송된다.\n\n# [네트워크 계층 TCP 자료](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_09_03.pdf)\n\n문제  \n01\n\n멀티플렉싱에 대한 설명 중 잘못된 것을 고르시오.\n\n상방향 멀티플렉싱은 다수의 전송 계층 연결에 대해 하부의 네트워크 계층에서 연결이 하나 형성된다.\n\n하방향 멀티플렉싱은 하나의 전송 연결 설정을 의미하는 포트에 다수의 가상 회선을 할당한다.\n\n상방향 멀티플렉싱은 네트워크 계층에서 만들어지는 가상 회선 연결의 개수를 줄일 수 있다.\n\n하방향 멀티플렉싱은 전송 속도를 높이고, 데이터 특성에 따라 그룹 가상 회선을 할당한다.\n\n4\n\n하방향 멀티플렉싱은 전송 속도를 높이고, 데이터 특성에 따라\n개별 가상 회선을 할당하여 효과적인 통신이 가능하다.\n\n문제  \n02\n\n전송계층에서의 3단계 설정 과정으로 해당하지 않는 것은?\n\nconnection request\n\nconnection response\n\ndata request\n\ndisconnection request\n\n4\n\nconnection request, connection response, data request은 전송계층에서의 3단계 설정 동작 과정을 나타낸다. disconnection request는 이에 해당하지 않는다.\n\n문제  \n03\n\n인터넷 환경에서 사용하는 well-known 포트가 아닌 것은?\n\nFTP(데이터 채널) : 20\n\nFTP(제어 채널) : 21\n\nTelnet : 23\n\nHTTP : 25\n\n4 HTTP 는 80 또는 8080 사용\n\n---\n\n# [네트워크 계층의 UDP란?](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_10_01.pdf)\n\n\\**\n\n1. UDP(User Datagram Protocol)\\*\\*\n\n* 비연결형 서비스를 제공\n* 헤더와 전송 데이터에 대한 체크섬 기능을 제공\n* Best Effort 전달 방식을 지원\n* TCP보다 데이터 처리가 빠르므로 데이터 전송 시간에 민감한 응용 환경에 적합\n* 프로토콜의 오버헤드가 작은 편임\n* 비연결형 서비스를 이용하여 데이터그램을 전송\n* 흐름 제어 기능이 없어 버퍼 오버플로Buffer Overflow에 의한 데이터 분실 오류가 발생할 수 있음 \n\n﻿**2. RTP(Real Time Protocol)**\n\n* 실시간 멀티미디어 데이터의 전송을 지원\n* 유니캐스팅뿐 아니라 멀티캐스팅도 지원\n* 불규칙한 데이터의 순서를 정렬하기 위해 타임스탬프(Timestamp) 방식을 사용\n* 지터(Jitter) 분포 : 데이터그램의 도착 시간을 측정하였을 때 각 데이터그램의 도착 시간이 불규칙적으로 도착하는 정도를 나타냄\n\n---\n\n# [OSI 7 계층에서 전송 프로토콜](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_10_02.pdf)\n\n**1. RTP의 데이터 전송**\n\n* 실시간 서비스를 위해 작고 빠른 전송 기능을 제공하는 UDP 위에서 구현  \n   •데이터그램 분실이나 도착 순서 변경과 같은 전송 오류는 RTP 자체에서 해결  \n   •송수신 프로세스 간의 연결을 관리\n* 하나의 완전한 프로그램 단위로 구현되지 않고, 기능별로 개별로 구현\n* 다수의 사용자가 하나의 세션에 참여, 서로 실시간 데이터 전송을 지원\n* 믹서(Mixer) : RTP 데이터그램 스트림을 받아 이들을 적절히 조합하여 새로운 데이터그램 스트림을 생성\n* 트랜슬레이터(Translator) : 입력된 각 RTP 데이터그램을 하나 이상의 출력용 RTP 데이터그램으로 만들어주는 장치\n* RTP 제어 프로토콜(RTCPRTP Control Protocol)\n* 주요 기능\n* QoS(Quality of Service)와 혼잡 제어 : 데이터 분배 과정에서 발생하는 서비스 품질에 관한 피드백 기능을 지원  \n  - Identification(구분자) : RTCP 송신 프로세스에 관한 구분자 정보가 포함, 서로 다른 세션에서 발신된 스트림 정보들을 서로 연관시키는 근거를 제공\n* 세션 크기 : 전체 세션 트래픽의 5% 이내로 유지되도록 알고리즘이 동작 \n\n﻿**2. OSI TP 프로토콜이 제공하는 서비스** \n\n* 클래스 0이 구조가 가장 단순, 클래스 번호가 커질수록 기능이 추가\n* OSI TP의 서비스 프리미티브\n* 연결형 서비스 : 연결 설정(T-CONNECT), 연결 해제(T-DISCONNECT), 일반 데이터(T-DATA), 긴급 데이터(T-EXPEDITED-DATA)\n* 비연결형 서비스 : 데이터 전송을 위한 T–UNITDATA 프리미티브만 존재\n\n---\n\n# [OSI 7 계층에서의 상위 계층](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_10_03.pdf)\n\n**1. 세션 계층의 기능**\n\n* 세션 연결의 설정과 해제, 세션 메시지 전송 등\n* 동기(Synchronization) 기능\n* 대화Dialogue 단계 \n\n﻿**2. 토큰 종류**\n\n* 데이터 토큰 : 데이터를 전송할 수 있는 권리 제공\n* 해제 토큰 : 통신 양단 간의 연결 해제 과정을 제어하기 위해 사용\n* 동기 토큰 : 세션 연결을 사용하는 과정에서 동기 처리가 필요한 지점에 사용 \n\n﻿**3. 재동기 기능**\n\n* 주동기점  \n     • 주동기점이 설정된 곳은 완벽히 처리되었다는 의미  \n     • 주동기점 이전의 복구 과정은 필요하지 않음\n* 부동기점  \n    • 복구에 필요한 백업 정보가 상대적으로 적음  \n    • 오류 복구가 완벽히 이루어지지 않을 수 있음  \n    • 이전 부동기점에서 복구가 불가능하면 직전 부동기점으로 이동하는 과정을 반복 \n\n﻿**4. 표현계층**\n\n* 데이터 압축  \n    • 대용량 데이터는 압축하여 크기를 줄인 후 전송하는 것이 속도에서 유리함  \n    • 데이터의 특성에 맞는 알고리즘을 사용하는 것이 중요함\n* 비손실 압축 \n\n﻿  • 압축 과정에서 원래 데이터의 내용을 분실하지 않음  \n  • 압축 해제 과정을 통해 원래의 데이터를 100% 복원  \n- 손실 압축  \n  • 압축 과정에서 원래 데이터의 내용을 부분적으로 분실  \n  • 압축 해제 과정을 통해 원래의 데이터를 100% 복원할 수 없음  \n  • 압축 효율을 높이기 위하여 사용\n\n---\n\n# [소켓시스템의 정의 및 기능](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_11_01.pdf)\n\n**1. 소켓의 주소 체계**\n\n* 프로그래밍 환경에서 AF_UNIX와 AF_INET 소켓 주소 체계 가장 많이 사용 \n\n﻿**2. 유닉스 주소 체계 AF_UNIX**\n\n* 하나의 호스트 내부에서 실행되는 프로세스 사이의 통신을 지원\n* 사용하는 주소 체계는 파일 시스템의 경로명을 기반으로 함 \n\n﻿**3. 인터넷 주소 체계 AF_INET**\n\n* 서로 다른 호스트에서 실행되는 프로세스 사이의 통신을 지원\n* 소켓이 생성되는 호스트의 32비트 IP주소와 16비트의 포트 번호를 조합하여 소켓 주소 표현 \n\n﻿**4. 통합 주소 체계**\n\n* 운영체제에서 제공하는 통신 프로토콜마다 주소 체계를 지원하는 문법 구조가 다름\n* 소켓 주소의 사용은 동일한 소켓 시스템 콜을 통해 이루어짐\n* 의미는 같으나 형식이 다른 여러 구조체를 하나의 함수에서 수용하는 것은 문법적으로 불가능\n* 따라서 모든 주소 체계를 수용할 수 있는 공통 주소 체계가 필요함\n* 프로그래밍 환경에서의 문법적인 측면만 고려하여 정의 \n\n﻿**5. 소켓의 서비스**\n\n* 제공되는 서비스 종류에 따른 소켓 유형도 다양하게 존재 \n\n﻿**6. 소켓의 유형**\n\n* SOCK_STREAM : 연결형 서비스를 제공받을 때 사용\n* SOCK_DGRAM : 비연결형 서비스에서 사용\n* SOCK_RAW : IP 프로토콜을 직접 사용해 통신할 때 사용함\n\n---\n\n# [소켓 시스템의 시스템 콜](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_11_02.pdf)\n\n\\**  \n1. socket( ) 함수\\*\\*\n\n* 데이터 전송에 사용되는 소켓을 생성할 때 호출\n* 소켓을 성공적으로 생성하면 소켓 디스크립터를 반환함 \n\n﻿**2. bind( ) 함수**\n\n* 생성된 소켓에 주소를 부여함 \n\n﻿**3. listen( ) 함수**\n\n* 소켓에서 대기할 수 있는 클라이언트의 연결 요청 개수를 지정 \n\n﻿**4. accept( ) 함수**\n\n* 서버 프로그램에서 클라이언트의 연결 요청을 대기 \n\n﻿**5. connect( ) 함수**\n\n* 연결형 서비스에서 클라이언트 프로세스가 서버 프로세스에 연결 요청 \n\n﻿**6. send( ) 함수**\n\n* send( ) 함수 : 연결형 서비스에서 데이터 송신에 사용\n* sendto( ) 함수 : 비연결형 서비스에서 사용 \n\n﻿**7. recv( ) 함수**\n\n* 상대 프로세스가 전송한 데이터를 소켓을 통해 읽음\n* recv( ) 함수 : 연결형 서비스에서 사용\n* recvfrom( ) 함수 : 비연결형 서비스에서 사용\n\n---\n\n# [네트워크 프로그래밍을 통한 소켓 시스템](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_11_03.pdf)\n\n**1. 연결형 서비스**\n\n* 소켓 : 네트워크 통신을 위한 소프트웨어 교신점 \n\n﻿**2. 서버와 클라이언트의 동작**\n\n* Well-known 포트로 자신의 소켓 주소를 설정 \n\n﻿**3. 비연결형 서비스**\n\n* connect()와 accept() 함수 생략\n* 데이터 송수신을 위한 sendto(), recvfrom() 함수 사용\n* 전송 데이터마다 수신자의 포트 번호 함께 전송 \n\n﻿**4. 암호화 용어**\n\n* 암호화 : 내용을 변형하여 원래의 의미를 알아볼 수 없도록 변형하는 작업\n* 해독 : 암호화된 문서를 원래 언어로 변형\n* 원문서 : 암호화 전의 원본 문서, 암호문 : 임의의 형태로 암호화한 문서 \n\n﻿**5. 암호화 알고리즘**\n\n* 암호키(kE) : 암호화 과정에서 사용하는 키\n* 해독키(kD) : 해독 과정에서 사용하는 키\n* 대칭키 방식 : 암호키와 해독키가 같음\n* 비대칭키 방식 : 암호키와 해독키가 다름 \n\n﻿**6. 대체 암호화**\n\n* 임의의 문자를 다른 문자로 대체하는 암호화 \n\n﻿**7. 키워드 암호화**\n\n* 지정 단어를 암호문 앞줄에 적고, 키워드에 표시된 문자를 뺀 나머지 문자를 알파벳순으로 기술하는 방식 \n\n﻿**8. 복수 개의 문자 변환표**\n\n* 문자 변환표를 둘 이상 사용\n* 장점 : 원문서의 동일 문자가 암호문에서는 다르게 암호화되므로 해독이 어려움 \n\n﻿**9. 위치 암호화**\n\n* 문자의 배열 순서를 변경해 암호화\n* 컬럼 암호화 : 전체 문장을 컬럼을 기준으로 다시 배치 \n\n﻿**10. 키워드 암호화**\n\n* 중복된 문자를 포함하지 않는 임의의 단어를 암호키로 제공\n\n---\n\n# [네트워크 보안 시스템](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_12_01.pdf)\n\n1. 암호화 시스템\n   1. DES 알고리즘\n   1. RSA 알고리즘\n   1. 전자서명\n1. 보안 프로토콜의 개요\n   1. 보안프로토콜의개요\n\n---\n\n# [보안 프로토콜과 웹의 연관성](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_12_02.pdf)\n\n1. 보안 프로토콜 (방화벽을 이용한 방법)\n   1. 보안 프로토콜\n1. 웹 (WWW)\n   1. 웹서비스\n   1. 웹 서비스의 동작 원리\n\n---\n\n# [웹 시스템 구조와 구현 가능 언어](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_12_03.pdf)\n\n1. 웹 시스템 구조\n   1. APM의 동작 원리 - apache php mysql\n   1. php 코드의 처리\n1. HTML, HTTP, CGI\n   1. HTML\n   1. HTTP의 요청과 응답\n   1. HTTP의 동작 과정\n   1. CGI\n\n---\n\n# [도메인 서비스와 도메인 서버 역할](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_13_01.pdf)\n\n1. 도메인 서비스\n   1. 도메인 서비스\n   1. DNS 서비스 \n      1. /etc/hosts 파일\n      1. nslookup - 도메인 이름가지고 ip주소 얻기\n\n---\n\n# [DNS 데이터베이스와 네임서버](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_13_02.pdf)\n\n1. DNS 데이터베이스\n   1. 도메인 네임 스페이스\n   1. 도메인 네임 스페이스의 구조\n1. 계층 구조의 네임서버\n   1. 데이터베이스 서비스\n   1. 자원레코드, 질의레코드\n   1. 자원레코드의 유형\n\n---\n\n# [네임서버의 기능 및 특징](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_13_03.pdf)\n\n1. 네임 서버의 기능 및 특징\n   1. 네임 서버와 해석기\n   1. 요청의 처리\n1. DNS 프로토콜\n   1. DNS메세지\n   1. DNS 프로토콜 동작 과정\n\n---\n\n# [전자메일 시스템으 ㅣ기능 및 역할](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_14_01.pdf)\n\n1. 전자메일 사용자 환경\n   1. 전자메일 사용자 환경\n   1. 메일 처리\n   1. MIME\n1. 전자메일 시스템 구조\n   1. 전자메일 시스템구조\n\n---\n\n# [전자메일 프로토콜](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_14_02.pdf)\n\n1. SMTP 서비스\n   1. SMTP\n   1. SMTP의 구조\n   1. SMTP의 명령과 응답\n   1. 연결 설정\n   1. 데이터 전송\n   1. 연결해제\n1. POP서비스\n   1. POP와 SMTP\n   1. POP명령과 응답\n   1. POP동작 시나리오\n\n---\n\n# [파일 전송 방법](https://www.smart.ac.kr/contents/LESSON_ONLY_1437/book/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%E2%85%A0_14_03.pdf)\n\n1. 파일 전송을 위한 사용자 환경\n   1. 파일 전송을 위한 사용자 환경\n1. FTP\n   1. FTP 구조\n   1. FTP\n   1. FTP명령과 응답\n1. TFTP\n   1. TFTP\n   1. TFTP 동작 과정\n","lastmodified":"2023-06-10T09:18:39.914057166+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3":{"title":"데이터베이스","content":"\nSQL을 이용한 데이터조작4\\](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_09_01.PDF)\n\n다음중 테이블에 투플을 직접 삽입할때 키워드아닌것 \n==from== insert into values\n\n테이블에 데이터 수정 키워드 알맞은것\nSELECT FROM, INSERT INTO, ALTER SET, ==UPDATE SET==\n\n데이터 삭제 옳지 않은것\n테이블에서 투플을 삭제하기 위한 SQL문은 DELETE를 사용한다.\n\n==WHERE절을 이용하여 제시한 조건을 만족하는 투플만 삭제하는 것이 가능하다.==\n\n테이블에서 WHERE절을 생략하고 투플을 삭제하는 SQL문을 실행하면, DROP TABLE과 같은 동작을 수행한다.\n\n투플을 삭제할 때, 부속질의문을 사용할 수 있다.\n\n3\n\nWHERE절을 생략하고 투플을 삭제하는 SQL문을 실행하면, 모든 투플을 삭제한다.\n\n[가상테이블 뷰](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_09_02.PDF)\n뷰 설명 옳지 않은것\n3 일반테이블러 생성이 가능하며 뷰에서 뷰를 생성하는건 불가능하다\n\n* 생성가능함\n\n뷰를 생성할때 기반이되는 일반 테이블을 지정하기 위한 키워드 \nAS\nas와 함께 기본테이블에 대한 select문을 작성한다.\n\n삭제할 뷰와  관련된 다른 뷰를 함께 삭제하는 키워드 \nCASCADE\n관련된뷰가 존재할때 삭제 안하는 키워드는 restrict\n\n[삽입 SQL](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_09_03.PDF)\n\n삽입된 sql 문에서 sql문의 변수와 응용프로그램의 변수를 구분하는 기호는?\n: 변수이름\n\n삽입 SQL 문 시작 키워드 \nEXEC SQL\n\n응용프로그램의 for, while 문과 같은 반복문과 함께 사용해야하는, 커서를 이동시키는 삽입 SQL문은?\nFETCH\n\n---\n\n# [데이터베이스의 설계단계와 개념적 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_10_01.PDF)\n\n1. 데이터베이스 설계는 사용자의 다양한 요구 사항을 고려하여 데이터베이스를 생성하는 과정이다. \n\n1. E-R 모델과 릴레이션 변환 규칙을 이용한 설계의 과정은 총 5단계이며, 순서는 다음과 같다.\n\n   1) 요구 사항 분석 2) 개념적 설계 3) 논리적 설계 4) 물리적 설계 5) 구현\n\n---\n\n# [데이터베이스의 논리적 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_10_02.PDF)\n\n1. 논리적 설계는 DBMS에 적합한 논리적 스키마를 설계하는 것을 목적으로 릴레이션 스키마를 산출물로 한다.\n\n1. 논리적 설계에서는 다섯 가지 릴레이션 변환 규칙에 따라 개념적 설계를 릴레이션 스키마(논리적 스키마)로 변환한다.\n\n 1) 모든 개체는 릴레이션으로 변환한다.\n\n 2) 다대다(n:m) 관계는 릴레이션으로 변환한다.\n\n 3) 일대다(1:n) 관계는 외래키로 표현한다.\n\n 4) 일대일(1:1) 관계는 외래키로 표현한다.\n\n 5) 다중 값 속성은 릴레이션으로 변환한다.\n\n---\n\n# [데이터베이스의 물리적 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_10_03.PDF)\n\n1. 물리적 설계는 필요한 인덱스 구조나 내부 저장 구조 등 물리적 구조를 설계한다. \n\n﻿2. 구현은 SQL문로 작성한 명령문을 DBMS에서 실행하여 데이터베이스를 생성한다.\n\n---\n\n# [정규화의 개념과 이상현상](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_11_01.PDF)\n\n1. 이상현상은 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터를 삽입, 수정, 삭제 연산을 수행할 때 발생하는 부작용이다.\n\n1. 정규화는 이상현상을 제거하면서 데이터베이스를 올바르게 설계하는 과정이다.\n\n---\n\n# [함수 종속과 기본 정규형](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_11_02.PDF)\n\n1. 어느 시점에서든 릴레이션 내의 모든 투플에서 속성 집합 X값 각각에 대한 속성 집합 Y값이 항상 하나면 “Y가 X에 함수적으로 종속되어 있다”라고 한다.\n\n1. 함수 종속 다이어그램은 릴레이션 하나를 구성하는 속성들 간에 함수 종속 관계를 도식화하여 표현한 것이다.\n\n1. 정규화는 함수 종속성을 이용하여, 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해 이상 현상이 발생하지 않는 바람직한 릴레이션으로 만드는 과정이다.\n\n---\n\n# [정규화 과정](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_11_03.PDF)\n\n1. 정규형 과정에서 제거해야 하는 함수종속 중에서 세 속성 집합이 연결되어 있는 이행적 함수 종속이 있다.\n\n1. 정규화는 비정규형 릴레이션에서 특정 함수종속을 제거하는 것으로 진행된다.\n\n---\n\n# [트랜젝션](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_12_01.PDF)\n\n1. 트랜잭션의 개념\n   1. 1\n   1. 트랜잭션의 예 1\n   1. 예2\n1. 트랜잭션의 특성\n   1. acid 특성\n   1. 특성 원자성\n   1. 특성 일관성\n   1. 특성 격리성\n   1. 특성 지속성\n\n---\n\n# [트랜잭션 장애와 회복](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_12_02.PDF)\n\n1. 트랜잭션의 기능\n   1. 주요연산\n   1. commit 연산\n   1. rollback 연산\n   1. 트랜잭션의 상태\n1. 데이터베이스 장애\n   1. 장애\n   1. 데이터베이스를 저장한느 저장 장치으 ㅣ종류\n   1. 트랜잭션의 수행을 위해 필ㅇ됴한 데이터 이동 연산\n   1. 디스크와 메인 메모리 간의 데이터 이동 연산의 필요성\n   1. 메 인 메 모 리 와 변 수 간 의 데 이 터 이 동 연 산\n   1. 트랜잭션을 데이터 이동 연산을 포함한 프로그램으로 표현한 예\n\n---\n\n# [장애와 회복](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_12_03.PDF)\n\n1. 데이터베이스 회복\n   1. 회복 - 특정시점으로 복구\n   1. 회복을위한 복사본 만드는 방법\n   1. 로그를 이용한 회복연산\n   1. 로그파일\n   1. 로그 기록 예\n   1. 회복 기법\n   1. 즉시 갱신 회복 기법\n   1. 지연갱신 회복 기법\n   1. 검사시점 회복기법\n   1. 미디어 회복기법\n\n---\n\n# [병행수행과 병행 제어](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_13_01.PDF)\n\n공용도\n응답시간\n트랜잭션 시나리오\n병행수행 제어안됬을때 문제점\n갱신 분실\n모순성\n\n---\n\n# [병행제어와 트랜잭션 스케줄1](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_13_02.PDF)\n\n연쇄 복귀\n직렬 , 비직렬 직렬가능 스케줄\n\n---\n\n# [병행제어와 트랜잭션 스케줄2](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_13_02.PDF)\n\n직렬가능 스케줄\n병행제어 기법\n로킹 기법\n공용 전용 lock\n2단계 로킹 규약\n교착상태\n\n---\n\n# [데이터베이스 보안과 권한](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_14_01.PDF)\n\n물리적 환경, 권한관리, 운영관리 를 통한 보안\n권한관리 개념\n접근제어\n허용된 권한 내에서만 데이터베이스 사용가능\nGARANT문 권한 부여\nREVOKE문 권한 삭제\n\n---\n\n# [데이터베이스 역할과 객체지향 데이터베이스](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_14_02.PDF)\n\n역할 - 여러 권한을 그룹으로 묶은것\n역할별로 권한을 부여\ncreate role\ndrop role\n객체지향 데이터 모델 \n\n---\n\n# [객체 관계 및 분산 데이터 베이스](https://www.smart.ac.kr/contents/LESSON_ONLY_1439/book/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_14_03.PDF)\n\n객채 지향 vs 객체 관계\n분산 데이터베이스 물리적으로 분산\n데이터 중복 장단점\n단편화\n","lastmodified":"2023-06-10T09:18:39.908896886+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%83%E1%85%B5%E1%84%8C%E1%85%B5%E1%84%90%E1%85%A5%E1%86%AF-%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB":{"title":"디지털 공학개론","content":"\n[게이트 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_09_01.PDF)\n\nex-or 게이트의 구성게인트가 아닌것 \n4 NAND\nand or not 으로 이루어져있음\n\n조합논리회로는?\n3 EX-OR\n\n[반가산기 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_09_02.PDF)\n\n조합회로의 설계목표 잘못\n2 복잡한게이트 구조 - 성능 극대화\n\n최소 개수의 게이트 이용 - 최저비용\n간단한구조 - 최소공간\n적은수의단계 - 고속\n\n[전가산기 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_09_03.PDF)\n조합회로 설계시 안하는거\n진리표를 보고 논리도를 그린다\n\n카르노맵이나 퀸 맥클러스키 방법으로 간략화하고 논리도를 그린다\n\n---\n\n# [병렬 2진 전가산기 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_10_01.PDF)\n\n1. 2진수 덧셈을 병렬로 완벽하게 하기 위해서는 캐리 미리 찾는 회로가 필요하다.\n\n1. 캐리미리 찾는 회로는 전단계 전가산기가 계산되기 전에 올림수를 미리 알 수 있도록 설계된 회로이다. \n\n1. 캐리미리 찾는 회로와 병렬가산기가 결합된 가산기는 완벽하게 병렬로 덧셈을 할 수 있다.\n\n---\n\n# [반감산기와 전감산기](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_10_02.PDF)\n\n**1. 가감산기 (adder-subtracter)** \n\n덧셈과 뺄셈을 모두 수행할 수 있는 산술회로 뺄셈도 덧셈으로 수행 가능\n\n**2. 전감산기**\n\n2진수를 완벽하게 감산처리 2진수 3개(빌림수 포함)를 처리해야 하므로 전감산기가 필요하다.\n\n**3. 반감산기**\n\n반감산기를 2진수 2개를 처리하기 위한 감산회로이다.\n\n---\n\n# [디코더](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_10_03.PDF)\n\n* 디코더 : 해독기라고도 부름\n\n* 입력 : N-비트 2진수\n\n* 출력 : 입력 값에 따라  ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1440/30/data/S_LESSON_ONLY_1440_20191101141101.jpg)개의 출력들 중의 하나를 지정\n\n---\n\n# [인코더 멀티플렉서](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_11_01.PDF)\n\n\n\n\n\n\n\n---\n\n# [디멀티플렉서, 코드변환기](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_11_02.PDF)\n\n\n\n\n\n\n\n\n\n---\n\n# [패리터 발생회로](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_11_03.PDF)\n\n\n\n\n\n\n---\n\n# [플립플럽1](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_12_01.PDF)\n\n패리티 비트 발생회로 설계 복습\n플립플럽은두개의출력단자,즉정상출력과부정출력을 갖는것으로출력상태를변화시킬입력값이들어오지 않는이상계속특정상태를유지하는기억소자\n비 동 기 식 RS - F F\n동기식\n동 기 식 J K - F F\n\n---\n\n# [플립플럽 2](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_12_02.PDF)\n\n동기식 T\n동기식 D 임시기억장치로 사용\n\n---\n\n# [순차회로1](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_12_03.PDF)\n\n§ 순차회로는입력,출력,메모리요소상태의시순차로표시 \n§ 순차회로분석은입력과출력,메모리요소상태의 시순차를 표나도식을얻음으로이루어짐\n상태표\n\n---\n\n# [순차회로2](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_13_01.PDF)\n\n진리표 및 여기표\nRS 플립플럽\nJK 플립플럽\n\n---\n\n# [순차회로3](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_13_02.PDF)\n\n순차회로 설계 절차\n1 § 회로의동작을순서대로정리한다.\n2 § 회로에관해주어진정보로상태표,상태도또는 상태방정식을얻는다.\n3 § 만일상태표,상태도에서상태문자기호로 표시되었으면문자에2진값을할당한다. \n4 § 사용될플립플럽의형을선택한다. \n5 § 상태표에서여기표와출력표를유도한다.\n6 § 카르노도와같은단순한방법을써서회로출력함수와 플립플럽의입력함수를간략화한다.\n7 § 논리회로를그린다\n\n---\n\n# [순차회로4](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_13_03.PDF)\n\n카운터, 설계\n\n---\n\n# [순차회로 5](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_14_01.PDF)\n\n8진 카운터\n카운터 설계\n\n---\n\n# [순차회로6](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_14_02.PDF)\n\n16진 카운터\n10진 카운터\n\n---\n\n# [레지스터](https://www.smart.ac.kr/contents/LESSON_ONLY_1440/book/%EB%94%94%EC%A7%80%ED%84%B8%EA%B3%B5%ED%95%99%EA%B0%9C%EB%A1%A0_14_03.PDF)\n\n4비트 레지스터\n병렬입력\n자리이동\n","lastmodified":"2023-06-10T09:18:39.924412477+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%A5":{"title":"마이크로프로세서","content":"\n[ASM 차트를 이용한 엘리베이터 설계](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_09_01.pdf)\n엘리베이터 있는 위치 표시 장치\n4 층표시 장치\n\nH 브리지 회로에 연결되어 엘리베이터 올리거나 내리는 역할 하는것은?\nDC모터\n\n스위치로 엘리베이터 요구 장치\n엘리베이터 요청 스위치\n\n[타이머 카운터 필요성](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_09_02.pdf)\n외부 펄스 발생시 하드웨어적으로 계수되는 카운터 값을 저장하는 기능\n입력 캡쳐 기능\n\n타이머 카운터클록 에서 내부동기 클록에 사용되는것은?\nCPU 클록\n\n0부터 증가하다가 OCRn값과 일치하면 0이되고 다시 증가하는것은?\nCTC모드의 계수\n\n[8비트 타이머카운터n오버플로인터럽트](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_09_03.pdf)\n\n인터럽트 발생했을때 기억시킬 필요 없는것\nInstruction register\n\nAccumulator, State Register, Program Counter 를 기억해야한다.\n\n**1. ATmega128에서**\n\n* int는 2byte, long형은 4byte로써 long형 정수 상수\n* 256은 2byte int형 정수, 256L은 4byte long형 정수\n* int형 * int형  int형, 256*256=28*28=216, 2byte(16비트) 정수로 오버플로\n* long형 정수 연산으로 정수형 자료 오버플로 발생 방지 \n\n﻿**2. 타이머/카운터n 오버플로 인터럽트 사용을 위한 초기화**\n\n* volatile unsigned long 자료형의 글로벌 변수로 타이머 변수 선언\n* TCNTn 클록 소스 초기화 : 내부 클록으로 초기화되어 있음.\n* ISR(TIMERn_OVF_vect) { }에 타이머/카운터0 인터럽트 서비스 루틴을 작성\n* TCCRn 레지스터의 WGMn1~WGMn0 파형 발생모드 비트를 설정\n* TCCRn 레지스터의 CSn2~CSn0 비트를 설정하여 인터럽트 발생 주기를 결정\n* TIMSK 레지스터의 TOIEn 비트를 1로 설정, 타이머/카운터n 오버플로 인터럽트 활성화\n* sei( ) 명령으로 전역 인터럽트를 활성화 \n\n﻿**3. 오버플로 인터럽트 발생 주기** \n\n![](http://www.smart.ac.kr/contents/LESSON_ONLY_1441/27/data/S_LESSON_ONLY_1345_20171215235811.jpg)ㅐ\n\n---\n\n# [요청/응답 인터페이스에 의한 LED점펼 주기 제어](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_10_01.pdf)\n\n**1. OCRn값 버퍼링 갱신으로 동일 PWM 주기 보장** \n\n﻿**2. OCRn 값을 수정할 때 OCn 출력 신호가 실질적 영향을 받는 시점**\n\n* 위치의 프로그램에서 OCRn 값 수정 -\u003e 내부 버퍼에 임시 저장  \n  - 위치에서는 아직 Ocn 출력 신호에 적용되지 않고 있음  \n  - 위치에서 OCRn 값이 실제 갱신됨  \n  - 위치에서 갱신된 OCRn과 TCNTn과 비교에 의해 OCn 신호 출력 \n\n**3. 오버플로 발생**\n\n* 고속 PWM 모드에서 오버플로는 TCNTn값이 최댓값인 FF일 때 발생\n* 주기마다 발생되고 시간 경과를 계산하는 기본 시간\n* 시간 경과를 알 수 있음(주기마다 타이머 변수를 1씩 증가시킴, 오버플로 발생 주기 x 증가 된 타이머 변수 값) \n\n﻿**4. 여러 주기의 LED와 7-세그먼트 LED 동작**\n\n* 16MHz로 동작되는 ATmega128 보드 사용\n* LED D1은 1초마다 반전\n* LED D2는 50\\[msec\\]마다 반전\n* 7-세그먼트 LED는 1초마다 1씩 증가하면서 디스플레이 \n\n**5. 매크로연산 사용을 줄여 연산시간 줄이기**\n\n* 56, 60, 64번 라인에서 매크로 정의 연산을 매번 수행\n* 1회 계산하고 double형 변수에 대입하여 사용함으로써 시간을 단축 \n\n﻿**6. 오버플로 인터럽트 체류 시간 줄이기**\n\n* 7-세그먼트 LED 교번 주기를 길게 변형\n* 길어지면 7-세그먼트 LED가 깜박거리는 현상이 관측\n* 적절한 프리스케일 값과 교번 주기를 결정\n\n\n\n\n---\n\n# [고속 pwm 을 이용한 dc 모터 속도제어](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_10_02.pdf)\n\n**1. 고속 PWM을 이용한 DC 모터 속도제어**\n\n* 7-세그먼트 LED 디스플레이를 위한 트랜지스터 설정 비트를 출력 방향\n* OC0(PB4) 핀을 출력 방향\n* 파형 발생모드를 고속 PWM 모드로 설정\n* 프리스케일러를 내부 CPU 클록의 256 분주로 설정\n* OC0 출력 극성을 TCNT0값이 OCR0과 일치하면 0이 되는 모드로 설정\n* 타이머 오버플로 인터럽트를 활성화\n* OCR0값을 바꾸면서 모터의 속도 변화를 관찰 \n\n﻿**2. 매크로 정의 및 변수 선언**\n\n* 2개의 요청/응답 인터페이스 변수 : req\\[NUM_REQ\\]\n* OCR0 디스플레이 변수 : number\n* 1회의 오버플로에 소요되는 시간 저장 변수 : ms_ov_cycle\n  \n\n\n\n\n\n---\n\n# [타이머/카운터2 고속 pwm을 이용한 rc 서보모터 구동](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_10_03.pdf)\n\n\n\n\n\n\n\n---\n\n# [16비트 타이머 카운터](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_11_01.pdf)\n\n**1. TCNTn 계수 방법, 오버플로 발생 시점, OCRnx 적용 시점** \n\n﻿1) 일반 모드\n\n* TCNTn은 0부터 1씩 증가되어 16비트 최댓값(FFFF)에 도달 후, 0부터 다시 증가\n* TCNTn의 계수가 0이 되는 순간 오버플로 인터럽트 발생\n* OCRnx값은 갱신 즉시 적용 \n\n﻿2) 고속 PWM 모드\n\n* TCNTn은 0부터 1씩 증가되어 최댓값(TOP)에 도달 후 0부터 다시 증가를 반복하는 계수 동작\n* TCNTn의 계수가 최댓값(TOP)에 도달되면 오버플로\n* 계수 최댓값(TOP)은 8비트(FF), 9비트(1FF), 10비트(3FF), ICRn, OCRnA 중 하나 선택\n* OCRnx 갱신은 TCNTn이 최댓값(TOP)일 때 적용 \n\n﻿3) 위상정정 PWM 모드\n\n* TCNTn은 0부터 최댓값(TOP)까지 증가 후 다시 1씩 0까지 감소하는 동작 반복\n* TCNTn의 계수가 0이 되면 오버플로\n* 계수 최댓값(TOP)은 8비트(FF), 9비트(1FF), 10비트(3FF), ICRn, OCRnA 중 하나 선택\n* OCRnx 갱신은 TCNTn이 최댓값(TOP)일 때 적용 \n\n﻿4) 위상-주파수정정 PWM 모드\n\n* TCNTn은 0부터 최댓값(TOP)까지 증가 후 다시 1씩 0까지 감소하는 동작 반복\n* TCNTn의 계수가 0이 되면 오버플로\n* 계수 최댓값(TOP)은 ICRn, OCRnA 중 하나 선택\n* OCRnx의 갱신은 TCNTn이 최솟값(0)일 때 적용 \n\n﻿5) CTC 모드\n\n* TCNTn은 0부터 증가하다 ICRn 또는 OCRnA값과 일치하면, 0으로 클리어된 후 다시 증가하는 동작 반복\n* 오버플로 인터럽트 발생 없음\n* OCRnA의 갱신은 OCRnA값을 바꾸는 순간 적용\n  \n\n\n\n\n---\n\n# [16비트 타이머/카운터 파형 발생모드와 OCnx신호](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_11_02.pdf)\n\n\\**\n\n1. OCnx 신호 조합 결정\\*\\*\n\n* TCNTn 레지스터와 OCRnx 레지스터의 비교일치 여부\n* 파형 발생모드(WGMn3~WGMn0) 설정\n* 비교일치 핀 출력 모드(COMnx1~COMnx0)\n* TOP값  \n      (TCNTn이 증가할 수 있는 최댓값)\n* BOTTOM 값  \n      (TCNTn이 감소할 수 있는 최솟값, 0)\n* 비 PWM 모드에서 FOCnx를 1로 설정하면 TCNTn과 OCRnx의 비교일치가 강제로 발생된 것처럼 설정 \n\n﻿**2. 비교출력 인터럽트**\n\n* 비교출력 인터럽트와 전역 인터럽트 비트가 활성화\n* OCRnx와 TCNTn이 일치되면 OCFnx 플래그가 1로 변하면서 인터럽트 발생을 요청\n* 인터럽트 서비스 루틴이 실행되면 OCFnx 플래그는 클리어\n* 인터럽트 서비스 루틴이 실행되기 전 OCFnx비트에 강제로 1을 기록하면 클리어\n* 인터럽트 서비스 루틴은 수행되지 않음.\n\n**3. 비교일치 인터럽트**\n\n* OCIEnx가 1로 설정하여 비교일치 인터럽트와 전역 인터럽트 활성화\n* TCNTn이 상승하는 과정에서 OCRnx와 값이 일치\n* ISR(TIMERn_COMPx_vect) 인터럽트 발생 \n\n﻿**4. 위상-주파수 정정 모드의 의미**\n\n* 16비트 위상정정 PWM 모드에 가변 TOP값(OCRnA, ICRn) 기능 추가\n* 위상정정 PWM 모드의 주기 구간은 TOP-TOP\n* OCRnx 변경이 TOP 위치에서 적용\n* OCRnA 변경으로 TOP 값을 수정할 때 주파수 왜곡이 생길 수 있음.\n  \n  \n  \n\n---\n\n# [16비트 타이머/카운터1 비교출력, OC1A/B/C 파형 생성 ](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_11_03.pdf)\n\n**1. 입력 캡처 사건 인터럽트 처리**\n\n* 인터럽트 활성화 비트 TICIEn와 전역 인터럽트 비트가 1로 활성화 된 경우 입력 캡처 상황이 발생 되면 TIFR 레지스터의 ICFn 비트가 1로 셋\n* 인터럽트 서비스 루틴 ISR(TIMERn_CAPT_vect)로 진입되면 ICFn은 0\n* 인터럽트 서비스 루틴 실행 대기 중에 ICFn 비트에 1을 기록하면 0으로 클리어되고, 인터럽트 서비스 루틴은 실행되지 않음 \n\n* ﻿**잡음 제거 기능과 에지 발생 인식**\n\n* ICNCn 설정 비트를 1로 활성화\n* 캡처 신호의 잡음에 의해 바운싱 현상이 나타날 수 있음\n* 동일한 신호가 연속해서 4회 이상 샘플링되었을 때 에지로 감지\n* 실제 입력 캡처 발생 순간보다 CPU 클록 4 펄스 지연되어 감지\n* TCCnB 레지스터의 ICESn 비트로 에지 선택\n  \n  \n  \n\n---\n\n# [디지털 입력핀 아날로그 비교기](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_12_01.pdf)\n\n디지털 시스템 사용신호와 자연신호의 변환\nadda\n버블 있을때 없을때\nASCR 레지스터\n비교기 인터럽트\n\n---\n\n# [적외선 포토 다이오드와 포토 트랜지스터](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_12_02.pdf)\n\n적외선 센서 , \n\n---\n\n# [아날로그 비교기를 이용한 검정띠 검출](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_12_03.pdf)\n\n---\n\n# [AD변환과 LED 밝기제어](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_13_01.pdf)\n\npwm 이용\n광센서 거리측정\n\n---\n\n# [동기 및 비동기모드 usart 통신](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_13_02.pdf)\n\nu 동기모드와 비동기모드 시리얼 통신\nu UDRn 레지스터와 데이터 송수신\n\n---\n\n# [폴링을 이용한 문자송수신](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_13_03.pdf)\n\n프레임 포맷 설정\n큐 인터럽트 이용 문자 송수신\n\n---\n\n# [문자 송수신 함수와 printf( ), scanf( )함수의 연결](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_14_01.pdf)\n\n(1)폴링을이용하여PC와비동기통신을위한문자송신,수신함수를작성 (2)printf(),scanf()함수와문자송수신함수를연결 (3)scanf()함수로입력받은정수를연산하여LCD창과PC측에출력 (4)부동소수점숫자를입력받고연산하여LCD창과PC측에출력\n\n---\n\n# [SPI 마스터/슬레이브 모드 고정 및 변경 동작, 관련 레지스터](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_14_02.pdf)\n\n• SPI(SerialPeripheralInterface) \n• 보통주변장치가마스터,마이크로컨트롤러는슬레이브로동작\n§ 주변장치로부터데이터를주기적으로수신 \n• SPI통신을위한마스터와슬레이브사이의신호연결 \n§ MISO,MOSI,SCK,/SS신호를사용\n\n---\n\n# [SPI(Serial Peripheral Interface) 통신](https://www.smart.ac.kr/contents/LESSON_ONLY_1441/book/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%E2%85%A0_14_03.pdf)\n","lastmodified":"2023-06-10T09:18:39.931100094+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC":{"title":"시스템프로그래밍","content":"\n### [컴퓨터 구조의 접근방법](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_03_01.PDF)\n\n1. 컴퓨터와 레지스터 디자인\n1. LOAD \u0026 STORE 명령어 디자인\n1. direct 모드와 indirect 모드\n\n### [프로세스의 생성과 소멸 1](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_03_02.PDF)\n\n1. 프로세스란 무엇인가\n1. 프로세스 스케줄링과 상태 변화\n1. 컨텍스트 스위칭\n\n### [프로세스의 생성과 소멸2](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_03_03.PDF)\n\n1. 프로세스의 생성\n1. 프로세스 생성과 문제점\n\n### [ 커널 오브젝트에 대한 이해와 핸들의 종속 관계](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_04_01.PDF)\n\n1. 커널 오브젝트에 대한 이해\n   1. 커널과 운영체제는 같은 의미\n   1. 커널(운영체제)에서 관리하는 중요한 데이터 블록이 - 커널 오브젝트\n1. 커널 오브젝트와 핸들의 관계\n1. 예제를 통한 종속 관계 이해\n\n### [프로세스간 통신 IPC](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_04_03.PDF)\n\n1. 프로세스간 통신의 의미\n1. 메일슬롯 방식의 IPC\n\n### [파이프방식의 IPC와 프로세스 환경변수](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_05_02.PDF)\n\n1. 파이프 방식의 IPC\n1. 프로세스 환경변수\n\n### [프로세스의 스케줄링](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_05_03.PDF)\n\n1. 일반 os와 리얼타임 os의 차이점\n1. \n\n### [임계 영역 접근 동기화와 유저 모드 동기화](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_09_01.PDF)\n\n크리티컬 섹션 동기화기법은 내부적으로 어떤 기반으로 구현?\n\n1. 인터락 함수 기반\n\n커널 모드로 전환이 불필요한 동기화 방법은?\n3. 유저모드의 동기화\n\n이름있는 뮤텍스기반, 뮤텍스기반, 세마포어기반 -\u003e 커널 모드 동기화\n\n커널모드 동기화 기법이 아닌것은?\n2. 크리티컬 세션 기반 동기화\n\n**1. 임계 영역에 대한 이해**\n\n* 쓰레드가 동시에 실행할 경우 문제가 발생하는 코드 블록을 임계 영역이라 한다.\n\n* 메모리 영역의 접근을 동기화\n\n**2. Windows는 다양한 동기화 기법**\n\n* 유저 모드 동기화\n\n   - 크리티컬 세션 기반의 동기화\n\n   - 인터락 함수 기반의 동기화\n\n* 커널 모드 동기화\n\n   - 뮤텍스 기반의 동기화\n\n   - 세마포어 기반의 동기화\n\n   - 이름있는 뮤텍스 기반의 프로세스 동기화\n\n   - Windows는 다양한 동기화 기법 제공\n\n      - 이벤트 기반의 동기화\n\n**3. 유저 모드의 동기화**\n\n* 커널 모드로의 전환이 불필요\n\n* 성능상의 이점\n\n**4. 크리티컬 섹션 기반의 동기화**\n\n* 화장실 열쇠에 비교하면 이해가 수월\n\n* 열쇠를 얻은 자만이 화장실 사용\n\n* 전역 변수 하나의 접근 방식\n\n**5. 인터락 함수 기반의 동기화**\n\n* 특별한 용도로 특화된 함수\n\n* 함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되도록 동기화\n\n* 크리티컬 섹션 동기화 기법도 내부적으로는 인터락 함수를 기반으로 구현\n\n---\n\n### [커널모드 동기화](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_09_02.PDF)\n\n임계영역에 접근가능한 쓰레드 개수를 조절하는 기능?\n카운트\n\n세마포어 기반 동기화엔 있고 뮤텍스 동기화에 없는건?\n카운트\n\n뮤텍스가 획득이 가능한 상태는?\nsignaled 상태\n\n**1. 커널 모드 동기화**\n\n* 유저 모드 동기화 보다 느림\n\n* 유저 모드에서 커널 모드로, 그리고 다시 커널 모드에서 유저 모드로의 전환이 필요\n\n* 유저 모드 동기화가 제공하지 못하는 기능 제공\n\n**2. 뮤텍스 기반의 동기화**\n\n* 커널 오브젝트는 상태를 지니는데, 그 하나는 Signaled 상태와 Non-Signaled 상태\n\n* “뮤텍스는 누군가에 의해 획득이 가능할 때 Signaled 상태에 놓인다.”\n\n**3. 세마포어 기반의 동기화**\n\n* 세마포어 중에서 단순화된 세마포어를 뮤텍스라 한다.\n\n   - 뮤텍스는 세마포어의 일종\n\n* 세마포어는 카운트 기능 존재\n\n   - 뮤텍스는 카운트 기능이 없음\n\n   - 임계 영역에 접근 가능한 쓰레드 개수를 조절하는 기능이 없음\n\n**4. 이름있는 뮤텍스**\n\n* 뮤텍스에 이름을 붙여 생성하는 경우\n\n   - 뮤텍스는 운영체제 소유\n\n* 프로세스 A에 의해 생성, 프로세스 B에서 접근 가능\n\n   - 커널이 관리하는 오브젝트이기 때문\n\n---\n\n### [실행순서에 있어서의 동기화와 이벤트 더하기 뮤덱스](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_09_03.PDF)\n\n이벤트기반 동기화 잘못된 설명\n3. 수동 리셋 모드는 블로킹된 함수 호출을 빠져나올 겨우 자동으로 non-signaled 상태가 된다.\n수동 리셋모드는 자동으로 변경되지 않아 수동으로 변경해야한다.\n\n이벤트 오브젝트 소멸으 위해 사용되는 함수는?\nCloseHandle\n\n입출력 속도차를 해결하기 위한 방법은?\n버퍼를 두고 두개의 쓰레드가 입출력 속도에 상관없이 독립적으로 실행되도록 한다.\n\n**1. 쓰레드의 실행 순서를 동기화하는 기법**\n\n* 메모리에 접근하는 쓰레드의 실행 순서 동기화\n\n   - 메모리 접근 동기화를 포함하는 개념\n\n**2. 생산자/소비자 모델**\n\n* 실행 순서의 동기화\n\n   - 실행되는 쓰레드의 순서가 중요\n\n   - 하나의 쓰레드가 입출력 모두 담당(문제점)\n\n**3. 입력과 출력 속도 차이 문제**\n\n* 입력되는 양이 많은 경우 쓰레드가 감당하지 못하므로 문자열이 소멸\n\n**4. 입력과 출력 속도 차이 문제 해결**\n\n* 두 개의 쓰레드를 활용, 하나는 입력, 또 하나는 출력을 담당\n\n* 두 쓰레드 사이에는 버퍼를 둬서 두 개의 쓰레드가 입력 및 출력 속도에 상관없이 독립적으로 실행되도록 함\n\n* 입력 및 출력 속도가 시스템의 CPU 속도에 비해 현저히 느리다면 좋은 선택이 됨\n\n**5. 이벤트 기반 동기화**\n\n* 동기화를 위한 오브젝트 사용\n\n   - 이벤트 오브젝트라함\n\n**6. 이벤트 오브젝트 소멸**\n\n* CloseHandle 함수 사용\n\n* 오브젝트가 Signaled 상태가 되어 브로킹 상태에 있던 쓰레드가 빠져나온다면?\n\n   - Signaled 상태 : 수동 리셋 모드\n\n   - 수동 리셋 모드(SignaledNon-signaled)\n\n   - ResetEvent 함수 호출\n\n   - Non-signaled :  자동 변경 시 자동 리셋 모드\n\n   - 자동 리셋 모드 (SignaledNon-signaled)\n\n   - WaitForSingleObject 함수 호출\n\n---\n\n### [타이머기반 동기화 종류와 쓰레드 폴링](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_10_01.PDF)\n\n일정시간 간격으로 알람이 울리는 타이머기반 동기화 기법은?\n주기적 타이머 기반 동기화\n\nIpTimerName 의미는?\n타이머 오브젝트 이름을 붙여줄경우 사용되는 전달인자\n\n타이머기반 동기화  잘못된설명\n타이머 기반동기화는 signaled상태에서  non-signaled 상태로 수동변경해야한다\n-\u003e 자동으로 signal 상태가 된다.\n-\u003e 쓰레드의 실행 시간및 주기를 결정할 수 있다.\n-\u003e 수동리셋타이머와 주기적 타이머가 있다.\n\n**1. 타이머 기반 동기화**\n\n* 정해진 시간이 지나면 자동으로 Signaled 상태가 되는 특성\n* 쓰레드의 실행시간 및 실행 주기를 결정하겠다는 의미\n* 타이머 기반 동기화 두 가지 형태  \n     - 수동 리셋 타이머 : 알람 시계와 같은 형태  \n     - 주기적 타이머 : 수동 리셋 타이머에 주기적인 특성 추가(10분마다 알람 설정)\n* 타이머 오브젝트는 무조건 Non-Signaled 상태\n\n**2. 쓰레드 풀에 대한 이해**\n\n* 생성과 소멸은 시스템에 많은 부담\n* 쓰레드의 재활용으로 성능 향상  \n     - 할당된 일을 마친 쓰레드를 소멸시키지 않고, 쓰레드 풀에 저장\n* 쓰레드 풀 동작 원리  \n     - 하나의 일 처리 후 소멸  \n     - 새로운 일 처리를 위해 생성  \n     - 처리해야 할 일이 많은 경우 성능 저하 \n\n﻿**3. 쓰레드 풀 동작 원리**\n\n* 지능적 풀은 쓰레드 개수 조절(증가/감소)\n* 쓰레드 수 \\\u003c 처리해야 할 일\n\n---\n\n### [쓰레드풀의 구현과 명령프롬프트 프로젝트 기능 추가](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_10_02.PDF)\n\n쓰레드에 새로운 일이 들어온경우 해야할 일\n이벤트 오브젝트 생성\n\n쓰레드풀 설명\nworklist 는 work를 등록하는 저장소다\nwork가 등록될위치를 가르쳐주는 인자가 필요하다\n처리해야 할 위치를 가르키는 인자가 필요하다\n-\u003e삭제를 위한 위치를 가르키는 인자는 필요없다.\n\n쓰레드풀을 구현하기 위한 멤버\nwork, 쓰레드 일에 관련된 멤버가 필요하다.\n\n**1. 쓰레드 풀의 구현**\n\n* 쓰레드에게 일을 시키기 위해서는 일에 해당하는 함수를 정의  \n     - 반환형과 매개변수 타입 모두 void형\n* Work에 관련된 멤버\n* 쓰레드에 관련된 멤버\n* 일에 관련된 멤버\n* workList는 work를 등록하는 저장소\n* idxOfLastAddedWork는 마지막에 추가된 Work index보다 1 많은 값을 유지하면서 새로운 Work가 등록될 때 등록 위치를 가르쳐준다.\n* 반면에 idxOfCurrentWork은 처리되어야 할 Work의 위치를 가리킨다.\n* 쓰레드에 할당된 일이 없는 경우  \n     - WaitFor~ 관련 함수 호출을 통해 Blocked\n* 새로운 일이 들어온 경우  \n     - 쓰레드 하나당 하나씩의 이벤트 오브젝트가 필요(workerEventList에 저장)\n* 증가는 하되 감소는 하지 않음  \n     - 해결 방안 : 원형 배열의 형태로 구현\n\n**2. 쓰레드 풀의 함수 관계**\n\n* 전역으로 선언된 쓰레드 풀 접근 동기화  \n     - 둘 이상의 쓰레드에 의해서 참조되는 메모리 영역  \n     - 뮤텍스 기반 동기화 함수들을 래핑\n\n---\n\n### [메모리 계층과 캐쉬, 캐쉬 알고리즘](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_10_03.PDF)\n\n컴퓨터 프로그램 일반적특성\nTemporal localtiy, Spatial locality Cache friendly code\nHard code -\u003e X\n\n메모리를 제외하고 연산에 필요한데이터 90퍼이상 존재하는 메모리는?\n캐시\n\n**1. 메모리 범위와 종류**\n\n* 하드디스크, RAM ,L2캐시, L1캐시, 레지스터\n* 메모리 계층 구조  \n     - 레지스터\u003eL1캐시\u003eL2캐시\u003eRAM\u003eHDD\n* 모든 메모리의 역할이 피라미드 구조에서 자신보다 아래에 있는 메모리를 캐시하기 위해 존재\n* 메인 메모리를 제외한 L1, L2 캐시에 연산에 필요한 데이터가 존재할 확률이 90% 이상\n\n**2. 컴퓨터 프로그램의 일반적인 특성**\n\n* Temporal locality란\n* Spatial locality란\n* Cache friendly code\n\n**3. 캐시 알고리즘**\n\n* 필요 데이터 이동  \n     - 데이터의 이동은 블록 단위  \n        블록 단위로 전송을 해서 spatial locality의 특성을 성능 향상에 십분 활용  \n     - 메모리의 피라미드 구조상 아래로 갈수록 블록 크기는 커진다.  \n        접근 횟수 최소화(성능 향상) 이유  \n        속도가 느리기 때문  \n     - 캐쉬 미스  \n        캐쉬 교체 정책  \n        LRU : 가장 오래전에 참조된 블록 삭제\n\n---\n\n# [가상메모리와 구조적 예외 처리 기법](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_11_01.PDF)\n\n**1. 물리 주소**\n\n* 임베디드 시스템과 범용 시스템의 차이점  \n     - 하드디스크의 존재 유무  \n     - 범용 시스템(HDD)  \n        Windows OS, 각종 소프트웨어 저장  \n        저장된 소프트웨어 기반 동작  \n     - 임베디드 시스템(not HDD)  \n        OS 없음  \n        플래시 메모리 사용  \n     - 물리적 주소 지정 방법  \n        RAM 크기에 따라 지정 가능한 주소의 범위 결정  \n        CPU는 접근 가능한 주소의 범위 제한적 \n\n﻿**2. 가상 주소**\n\n* 가상의 주소를 지정하는 방식  \n     - 가상 메모리 공간을 할당  \n     - 하드디스크 활용\n* 첫 번째 문제 : 선 할당으로 인한 부담  \n     - 미리 할당하는 것은 메모리 낭비\n* 두 번째 문제 : 느린 속도의 개선 필요성  \n     - 하드디스크의 느린 속도\n* 가상 메모리 구현 방법  \n     - 대부분 시스템에서 페이징 기법 사용\n* MMU(Memory management unit)  \n     - 블록 단위를 16바이트로 최소화 또는  \n     - 단위를 없애 버리고 필요한 만큼 할당될 경우  \n     - 메모리 사용의 효율성은 증가\n* 메모리 부족의 문제  \n    - 물리 메모리 FULL  \n    - 둘 이상의 프로세스 실행\n* HDD를 통해 문제 해결  \n     - 속도를 제외하면 기능은 동일  \n     - 스왑 파일(swap file) \n\n﻿﻿**3. 예외 처리의 필요성**\n\n* if문을 통해 예외 처리\n* 예외 처리를 위한 코드 별도 관리  \n     - 코드의 가독성 향상\n\n\n\n\n\n\n---\n\n# [종료 핸들러와 예외 핸들러](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_11_02.PDF)\n\n**1. 종료 핸들러**\n\n* SHE(Structured Exception Handling)  \n     - 구조적 예외처리 메커니즘을 기능적 특성에 따라 크게 두 가지로 분류  \n     - 종료 핸들러와 예외 핸들러\n\n**2. 종료 핸들러의 기본 구성과 동작 원리**\n\n* 종료 핸들러에서 사용되는 키워드 두 가지  \n     \\_try, \\_finally  \n     \\_try는 예외 핸들러에서도 사용  \n     종료 핸들러에서 사용될 때와 예외 핸들러에서 사용될 때 그 역할에 차이가 있다.  \n     \\_finally와 함께 사용될 때의 역할 의미\n\n**3. 종료 핸들러에서 사용되는 키워드 두 가지**  \n   - \\_try만 올 수 없고 \\_finally만 올 수도 없음  \n   - 둘 사이에는 다른 어떤 코드도 삽입 불가  \n   - 컴퍼일러는 이 둘을 하나의 문장으로 인식\n\n**4. 예외 핸들러**\n\n* 예외 핸들러는 예외 상황 발생 시 선별적 실행이라는 특징\n* 종료 핸들러는 무조건 실행이라는 특징\n* \\_try 블록에서 예외 상황 발생 시 \\_except 블록에서 상황 처리\n\n**5. 예외 필터**\n\n* 예외처리 메커니즘을 어떻게 동작시킬지 그 동작 방식을 결정하기 위한 영역\n\n\n\n\n\n---\n\n# [핸들러 중복과 소프트웨어 기반의 개발자 정의 예외](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_11_03.PDF)\n\n**1. 핸들러의 중복**\n\n* 핸들러는 중복 가능\n* 종료 핸들러와도 중복 가능\n\n**2. 예외의 종류와 예외 구분 방법**\n\n* 예외 발생 시 예외 종류 확인 방법  \n     - GetExceptionCode 함수 호출  \n        DWORD GetExceptionCode (void)  \n     - 발생한 예외 정보 획득  \n     - 시스템에서 발생할 수 있는 예외  \n        EXCEPTION_ACCESS_VIOLATION : 접근 위반이 발생하는 예외  \n        EXCEPTION_INT_DIVIDE_BY_ZERO : 정수를 0으로 나누려 할 때 발생  \n        EXCEPTION_CONTINUE_EXECUTION : 유효하지 않은 값 입력 시 다시 실행  \n        EXCEPTION_CONTINUE_SEARCH : 다른 곳에 있는 예외 핸들러로 예외 처리\n\n**3. 소프트웨어 기반의 개발자 정의 예외**  \n   - 개발자는 예외상황을 정의 및 추가 가능 \n\n﻿**4. 소프트웨어 예외의 발생**  \n   - 하드웨어 예외는 디자인될 당시 결정  \n   - RaiseException 함수  \n      - dwExceptionCode  \n         31번, 30번째 비트  \n         00 : Success(성공)  \n         01 : Informational(예외의 알림)  \n         10 : Warning(예외에 대한 경고)  \n         11 : Error(강도 높은 오류 상황) \n\n**5. GetExceptionInformation**\n\n* GetExceptionCode가 반환해 주는 정보보다 더 많은 정보를 얻기 위해 사용\n* 예외 필터 표현식을 지정하는 부분에서만 호출 가능\n  \n  \n  \n\n---\n\n# [기 본 적 인 파 일 처 리 함 수 I](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_12_01.PDF)\n\n파 일 열 기 \u0026 닫 기\n파 일 읽 기 \u0026 쓰 기 와 포 인 터\n시간 정보 얻어오기\n\n---\n\n# [기 본 적 인 파 일 처 리 함 수 Ⅱ](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_12_02.PDF)\n\n파 일 사 이 즈 얻 어 오 기\n파일의특성정보얻어오기\n파일의경로정보얻어오기\n파 일 포 인 터 의 이 동\n\n---\n\n# [디 렉 터 리 관 련 함 수 및 명 령 프 롬 프 트 프 로 젝 트](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_12_03.PDF)\n\n디렉터리생성및소멸을위한함수\nWi n d ows 디 렉 터 리 의 위 치 정 보 확 인\n디렉터리에서파일찾기\n명령어xcopy는디렉터리단위복사기능\n\n---\n\n# [비동기 I/O의 이해와 중첩 I/O그리고 완료 루팅 기반 확장 I/O](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_13_01.PDF)\n\n비동기I/O의 이해 § CPU사용내역확인하기\n중첩 io\n\n---\n\n# [OVERLAPPED 구조체의 파일 위치 정보와 APC](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_13_02.PDF)\n\nu OVERLAPPED 구조체의 파일 위치 정보\n타 이 머 에 서 의 완료 루 틴\nAPC § 비동기함수호출메커니즘을의미\n\n---\n\n# [메모리 관리](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_13_03.PDF)\n\n가상메모리컨트롤\nReserve,Commit 그리고Free\nDynamic Array Design § 점진적으로증가하는배열디자인\n\n---\n\n# [힙 컨트롤](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_14_01.PDF)\n\n리스트 자료구조 특성\n각각의 리 스트 정 보는 동적 할 당되 어 힙 에 저 장 \n• 메 모 리 반환의 과정 필 요 \n• 리 스트의 처 음부 터 끝까지 추적 해 가 면 일 일 이 반환\n\n---\n\n# [힙 컨 트 롤 과 M M F](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_14_02.PDF)\n\n힙의생성과소멸그리고할당\nMemoryMappedFile의약자\n장점 1 • 프로그 래 밍 하기 편 리 하 다 . • 메 모 리 상에 저 장된 데 이 터 조작 편 의 성 장점 2 • 성 능 이 향상된 다 . • 메 모 리 는 중간에 서 파 일 데 이 터 의 캐 시 역 할 - 직 접 파 일 에 접 근하는 것보 다 효율적 접 근\nmmf 구현 과정\n\n---\n\n# [Dynamic Linking Library](https://www.smart.ac.kr/contents/LESSON_ONLY_1447/book/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_14_03.PDF)\n\nu 라 이 브 러 리 와 p r i n t f !\nu 또 다 른 라 이 브 러 리 D L L\n헤더파일\n","lastmodified":"2023-06-10T09:18:39.922272871+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9":{"title":"자료구조","content":"\n### [트리1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_09_01.pdf)\n\n**1. 트리의 개념**\n\n* 계층적인 자료를 표현하는 자료구조이다.\n* 리스트, 스택, 큐 등은 선형자료구조이다.\n* 트리는 부모-자식 관계의 노드들로 이루어진다.\n* 응용분야 : 전형적인 예로는 회사의 조직구조이다. \n\n﻿**2. 트리에서 나타나는 용어들**\n\n* 노드(node) : 트리의 구성요소 A, B, C, D, E, F, G, H, I, J를 노드라 한다.\n* 루트(root) : 부모가 없는 노드 {A}\n* 서브트리(subtree) : 하나의 노드와 그노드들의 자손들로 이루어진 트리이다.  {B, E, F, G} {C, H} {D, I, J}\n* 간선(edge) : 루트와 서브트리를 연결하는 선이다.\n* 자식, 부모, 형제, 조상, 자손노드는 인관관계와 동일하다.\n* 부모노드 : A는 B,C,D의 부모노드이다.\n* 자식노드 : B,C,D는 A의 자식노드이다.\n* 형제노드 : B와 C와 D는 형제노드이다.\n* 단말노드(terminal node) : 자식이 없는 노드 (E,F,G,H,I,J) \n* 비단말노드 : 적어도 하나의 자식을 가지는 노드(A,B,C,D)  \n* 레벨(level) : 트리의 각층의 번호로 루트부터 1로 시작한다.\n* 높이(height) : 트리의 최대 레벨로 위 그림은 3이다.\n* 차수(degree) : 노드가 가지고 있는 자식 노드의 개수를 의미한다. A와 B노드의 차수가 3으로 가장크므로 전체 트리의 차수가 3이다.\n* 포리스트(forest) : 나무가 모이면 숲이되듯이 트리의 집합을 말한다. \n\n﻿**3.  이진트리(binary tree)소개**\n\n1. 모든 노드가 2개의 서브트리를 가지고 있는 트리\n\n* 이진트리의 서브트리는 공집합일 수 있다.\n* 이진트리의 노드에는 최대 2개까지의 자식노드가 존재한다.\n* 모든 노드의 차수가 2이하가 된다 --\u003e 구현하기가 편리하다.\n* 이진트리에는 서브트리간의 순서가 존재한다.\n* 왼쪽서브트리와 오른쪽서브트리는 서로 구별된다. \n\n2) 이진트리의 정의   \n     가. 공집합이거나  \n     나. 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성된 노드들의 유한집합으로 정의한다. 이진트리의 서브트리들은 모두 이진트리이어야 한다.\n\n3. 이진트리의 성질\n\n* 이진트리는 노드의 개수가 n개이면 간선의 개수는 n-1개이다.\n\n* 이진트리에서 노드는 루트를 제외하고는 하나의 부모노드를 가진다. 그리고 부모와 자식간에는 하나의 간선만이 존재한다.\n\n* 이진트리의 분류  \n     가. 포화이진트리(full binary tree)  \n     나. 완전이진트리(complete binary tree)  \n     다. 기타이진트리\n\n4)  이진트리의 표현  \n   가. 배열을 이용하는 방법  \n   나. 포인터를 이용하는 방법\n\n---\n\n### [트리2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_09_02.pdf)\n\n**1. 이진트리의 순회**  \n1) 순회(traversal)\n\n* 링크표현법의 트리는 루트노드의 포인터만 알면 트리안의 모든노드에 접근가능하다.\n* 연결리스트와 매우 비슷하며, 연결리스트는 1차원적 연결이고, 링크표현법은 2차원적 연결 구조이다.\n* 이진트리도 데이터 저장 방법인 자료구조이다.\n* 데이터는 노드의 데이터필드를 이용하여 저장한다.\n* 이진트리의 순회는 : 이진트리에 속하는 모든 노드를 한번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것이다.\n* 트리 사용목적은 트리의 노드에 자료를 저장하고 필요에 따라서 이 자료를 처리한다.\n* 이진트리의 순회는 중요한 연산이다. \n\n﻿**2. 이진트리 순회방법**\n\n* 3가지의 기본적인 순회방법\n* 이는 루트와 왼쪽서브트리, 오른쪽서브트리 중에서 루트를 언제 방문하느냐에 구분한다.\n* 루트방문을 V, 왼쪽서브트리 방문을 L, 오른쪽서브트리 방문을 R이라고 한다.      \n\n1. 전위순회(preorder traversal) : VLR\n\n* 자식노드보다 루트노드를 먼저 방문한다.\n\n2. 중위순회(inorder traversal) : LVR\n\n* 왼쪽자식, 루트, 오른쪽자식 순으로 방문한다.\n\n3. 후위순회(postorder traversal) : LRV\n\n* 자식노드를 먼저방문하고 루트노드를 방문한다.     \n\n4. 레벨순회\n\n* 각 노드를 레벨순으로 순회하는 방법\n* 지금까지의 순회법은 스택을 사용하였다.\n* 레벨순회는 큐를 사용하는 순회법이다. \n\n**3. 스레드 이진트리**\n\n* 이진트리의 NULL링크를 이용하여 순환호출 없이도 트리의 노드를 순회하는 방법\n* 이진트리 노드에 많은 NULL링크가 존재한다.\n* 트리의 노드개수 n이면, 총링크의 개수는 2n이다.\n* 이들중 n-1개의 링크들이 루트노드를 제외한 n-1개의 다른 노드를 가리킨다.\n* 2n개의 링크 중에서 n-1은 NULL링크가 아니고, 나머지 n+1개의 링크는 NULL이다.\n* NULL링크에 중위순회시에 후속노드인 중위후속자를 저장한 트리가 스레드이진트리이다.\n* 중위후속자만 저장한다고 가정한다.\n\n---\n\n\\###[트리3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_09_03.pdf)\n\n**1. 이진탐색트리의 정의**\n\n* 모든 노드의 키는 유일하다.\n* 왼쪽 서브트리의 키들은 루트의 키보다 작다.\n* 오른쪽 서브트리의 키들은 루트의 키보다 크다. \n\n﻿- 왼쪽과 오른쪽 서브트리도 이진탐색트리이다. \n\n﻿**2. 이진탐색트리에서의 탐색연산**\n\n* 이진탐색트리에서 특정 키 값을 가진 노드를 찾기 위해서는 주어진 탐색 키 값과 현재의 루트노드의 킷값을 비교한다.\n* 비교결과 다음 3가지로 분류된다.\n* 비교한 결과가 같으면 탐색이 성공으로 종료한다.\n* 주어진 키 값이 루트노드의 키값보다 작으면 탐색은 이 루트노드의 왼쪽자식을 기준으로 다시 시작한다.\n* 주어진 키 값이 루트노드의 키값보다 크면 탐색은 이 루트노드의 오른쪽자식을 기준으로 다시 시작한다. \n\n﻿**3. 이진탐색트리 삽입알고리즘(자연어 버전)**\n\n* insert_node(T, z)\n\n1. 트리 T에서 z에 대한 탐색을 먼저 수행한다.\n1. 탐색이 실패하면 탐색이 끝난 지점에 노드z를 삽입한다. \n\n﻿**4. 이진탐색트리에서의 삭제연산**\n\n* 삭제전에 트리 탐색으로 위치 파악의 3가지의 경우\n* 삭제하려는 노드가 단말노드일 경우\n* 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브트리 중 하나만 가지고 있는 경우\n* 삭제하려는 노드가 두 개의 서브트리 모두 가지고 있는 경우 \n\n﻿**5. 이진탐색트리의 성능분석**\n\n* 이진탐색트리의 탐색, 삽입, 삭제연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 h에 비례한다.\n* 시간복잡도는 높이 h일 때 O(h)이다.\n* 최선의 경우\n* 이진트리가 균형적으로 생성되어 있는 경우  \n  - ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/27/data/S_LESSON_ONLY_1348_20171121175954.jpg) \n* 최악의 경우\n* 한쪽으로 치우친 경사이진트리의 경우\n* h = n\n* 순차탐색과 시간복잡도가 같다.\n\n---\n\n### [우선순위큐1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_10_01.pdf)\n\n**1. 우선순위 큐**\n\n1. 우선순위 큐\n\n* 우선순위 큐(priority queue) : 우선순위를 가진 항목들을 저장하는 큐\n* FIFO 순서가 아니라 우선순위가 높은 데이터가 먼저 나가게 된다.\n\n2. 우선순위 큐 추상 데이터타입\n\n* 가장일반적인 큐 : 스택이나 FIFO큐를 우선순위 큐로 구현할 수 있다. \n\n![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/28/data/S_LESSON_ONLY_1348_20171126114615.jpg) \n\n3. 우선순위큐의 구현 방법\n\n* 배열\n\n* 연결리스트\n\n* ==히프(heap) : 가장 효율적인 방법==\n\n4. 히프는 완전이진트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.\n4. 히프는 반정렬상태를 유지한다.\n4. 반정렬상태를 이용하여 우선순위 큐를 구현한다.\n4. 히프의 시간복잡도는 ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/28/data/S_LESSON_ONLY_1348_20171126160649.jpg)으로 다른방법보다 유리하다.\n4. O(n)과 ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/28/data/S_LESSON_ONLY_1348_20171126114435.jpg)은 큰 차이가 있다.\n4. n이 1000의 경우 O(n)은 1000초가 걸린다. ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/28/data/S_LESSON_ONLY_1348_20171126114408.jpg)은 10초 걸린다.\n\n**2. 히프**\n\n1. 히프의 개념\n\n* 히프는 ‘더미’ 의미, 완전이진트리 기반의 ‘더미’와 비슷한 모습 특정 자료구조를 의미한다.\n* 히프는 여러개의 값중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만든 자료구조이다.\n* 히프는 보모노드의 키 값이 자식노드의 키 값보다 항상 큰(작은) 이진트리이다.\n* 즉 A가 B의 부모노드이고 부모노드의 키 값이 자식노드의 키 값보다 항상크다고 하면,  \n  다음 조건(히프조건)이 항상 성립하는 트리이다.  \n  key(A) \u003e= key(B)\n\n2. 최대히프(max heap)\n\n* 부모노드의 키 값이 자식노드의 키 값보다 크거나 같은 완전이진트리\n* key(부모노드) \u003e= key(자식노드)\n\n3. 최소히프(min heap)\n\n* 부모노드의 키 값이 자식노드의 키 값보다 작거나 같은 완전이진트리\n* key(부모노드) \\\u003c= key(자식노드)\n\n4. 히프는 완전이진트리이다.\n\n---\n\n### [우선순위 큐 2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_10_02.pdf)\n\n우선순위 큐는 완전이진트리로 최대값 ,최소값 삭제하기에 주로 사용된다.\n\n**1. 히프의 구현**\n\n* 히프는 완전이진트리로 노드에 차례대로 번호를 붙일 수있다.\n* 이 번호로 배열의 인덱스로 하여 배열에 히프 노드를 저장한다.\n* 히프를 저장하는 표준적인 자료구조는 배열이다.\n* 구현의 편의상 배열의 첫 인덱스 0은 사용하지 않는다.\n* 특정위치의 노드 번호는 새로운 노드가 추가 되어도 변한지 않는다.\n* 부모노드와 자식노드를 찾기는 쉽다.  \n  · 왼쪽자식의 인덱스 = (부모의 인덱스) * 2  \n  · 오른쪽자식의 인덱스 = (부모의 인덱스) * 2 + 1  \n  · 부모의 인덱스 = (자식의 인덱스) / 2 \n\n﻿**2. 히프트리의 삽입알고리즘 (자연어 버전)**\n\n1. 히프의 끝에 새로운 노드를 삽입한다.\n1. 삽입된 노드와 그 부모 노드의 키 값을 비교한다. 삽입한 노드의 키 값이 부모노드의 키 값보다 크면 두 노드의 위치를 바꾼다.\n1. 삽입된 노드의 키 값이 자신의 부모 노드 키 값보다 작아질 때까지 단계 2)를 반복한다. \n\n**3. 삭제연산**\n\n* 삭제연산은 회사에서 사장 자리가 비게 되면 먼저 제일 말단 사원을 사장 자리로 올린 다음에 능력에 따라 강등시키는 것과 비슷하다.\n* 최대 히프에서 삭제는 가장 큰 기 값을 가진 노드를 삭제하는 것을 의미한다. 따라서 루트노드가 삭제된다.\n\n---\n\n### [우선순위큐3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_10_03.pdf)\n\n글자의 빈도수를 이용하여 데이터를 압축하는것\n==허프만코드==\n\n시간적으로 먼저발생된 이벤트가 먼저처리되는 우선순위 큐 이용하는 이벤트\n이산 이벤트 시뮬레이션\n\n히프정렬 시간복잡도\nnlog2n\n\n**1. 히프의 응용**\n\n1. 히프 정렬\n\n* 최대히프를 이용하면 정렬이 가능하다.\n* n개의 요소는 ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/30/data/S_LESSON_ONLY_1348_20171126121745.jpg)시간 안에 정렬된다.\n* 요소의 개수가 n개이므로 전체적으로 ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/30/data/S_LESSON_ONLY_1348_20171126121604.jpg)의 시간이 걸린다.\n* 삽입정렬의 알고리즘의 ![](http://www.smart.ac.kr/contents/LESSON_ONLY_1454/30/data/S_LESSON_ONLY_1348_20171126121704.jpg)보다 좋다.\n* 먼저 정렬해야 할 n개의 요소들로 최대 히프를 초기화한다.\n* 한번에 하나씩 요소를 히프에서 삭제하여 배열의 뒤부터 저장하면 된다.\n* 삭제되는 요소들은 값이 감소되는 순서이다.\n* 히프정렬이 가장 필요한 경우는 전체자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필요할 경우이다.\n\n2. 이산이벤트 시뮬레이션\n\n* 모든 시간의 진행은 이벤트의 발생에 의해서 이루어진다.\n* 즉 이벤트가 발생되면 시간이 진행된다.\n* 많은 이벤트가 발생하고 이벤트들은 시간적으로 먼저 발생된 이벤트가 먼저 처리된다.\n* 우선순위큐를 이용하여 이벤트를 저장하고 이벤트의 발생시각을 우선순위로하여 처리하는 시뮬레이션을 만들어 보자\n\n3) 허프만 코드\n\n* 이진 트리는 각 글자의 빈도가 알려져 있는 메시지의 내용을 압축하는데 사용될 수 있다.\n* 이런 종류의 이진트리를 허프만 코딩 트리라고 부른다.\n* 위 테이블의 숫자는 빈도수라 한다.\n* 빈도수를 이용하여 데이터 압축을 각 글자들을 나타내는 최소길이의 엔코딩 비트열을 만든다.\n* 전체 데이터의 양을 줄이기 위하여 고정된 길이를 사용하지 않고 가변길이의 코드 사용한다.\n* 가장 많은 글자에는 짧은 비트열을 사용하고, 잘 나오지 않는 글자에는 긴 비트열을 사용한다.\n\n---\n\n# [정렬1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_11_01.pdf)\n\n비교가능하면 정렬 가능\n대상은 레코드\n레코드는 필드로 구성되어 있음\n키 필드 값으로 레코드를 서로 구분함\n\n알고리즘 평가는 비교연산횟수와 이동연산횟수의 효율성을 기준으로함\n빅오 표기법\n\n동일한 키값은 상대적 위치가 안변해야 안정성이 높은 알고리즘\n선택정렬 n^2 시간복잡도\n제자리 정렬\n삽입정렬 - 이미 정렬되어있는경우 효율적\n\n---\n\n# [정렬2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_11_02.pdf)\n\n버블 정렬 - 비효율적\n\n셀정렬 - 삽입정렬 개량버전 \n최악 n^2\n평균 n^1.5\n\n합병정렬\nnlog2n\n큰레코드를 정렬할떄 매우 효과적\n\n---\n\n# [정렬3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_11_03.pdf)\n\n퀵정렬\nnlog2n\n최악일때 n2\n\n히프정렬\n\n기수정렬\ndn    d\\\u003c10\n정렬할수 있는 레코드 타입이 한정됨\n레코드 키가 동일한 길이를 가져야함\n버켓이라하는 메모리가 공간을 추가로쓰지만 매우빠름\n\n\n\n---\n\n# [그래프1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_12_01.pdf)\n\n전기회로 소자간 연결상태\n지도에서 도시들의 연결상태\n오일러가 창안\n\n위치, 다리로 구성\n모든 위치(정점) 에 연결된 간선(다리)의 수가 짝수이면 오일러 경로가 존재\n\n그래프 G 는 (V,E)로 표시, 정점(vertex) 간선(edge)\n\n무방향 그래프, 방향 그래프\n\n가중치 그래프(간선에 비용이나 가중치(길이))\n\n\\\u003c0,1\u003e은 방향을 나타냄\n\n부분 그래프\n\n그래프의 경로\n\n트리 - 그래프의 특수한 형태, 사이클을 가지지 않는 연결 그래프\n\n완전그래프\n\n\n\n\n\n\n\n\n그래프 탐색\n\n\n\n\n---\n\n# [그래프2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_12_02.pdf)\n\n연결성분\n\n신장트리\n\n\n---\n\n# [그래프3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_12_03.pdf)\n\n최단경로\n\n\n위상정렬\n\n---\n\n# [해싱1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_13_01.pdf)\n\n해싱이란? \n• 키값비교에의한탐색방법은 정렬이안되어있으면O(n),정렬이되어있으면O(log2n)임.\n• 해싱은이론적으로O(1)의시간안에탐색을마침.\n• 해싱은사전과같은자료구조를구현할때최상의선택이됨.\n\ndictionary 자료구조\n\n---\n\n# [해싱2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_13_02.pdf)\n\n해시함수의 종류\n\n좋은 해시함수란?\n\n1. 충돌이적어야함.\n1. 해시함수값이해시테이블의주소영역내에서 고르게분포되어야함. \n1. 계산이빨라야함\n\n제산함수\n폴딩함수\n중간제곱함수\n비트추출방법\n\n충돌해결책\n선형조사법\n체이닝\n\n---\n\n# [해싱3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_13_03.pdf)\n\n이차조사법\n이중해싱법\n체이닝 - 버켓이 하나이상의 값을 저장하도록\n\n\n\n---\n\n# [탐색1](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_14_01.pdf)\n\n탐색키\n사용되는 자료구조\n\n손차탐색\n정렬된 배열에서 탐색\n\n이진탐색\n가운데부터 찾는거\n큰데서 찾는데 효율적  \nlog2n\n\n---\n\n# [탐색2](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_14_02.pdf)\n\n색인 순차 탐색\n\n보간탐색\n키값을참고하여 탐색하는법\nlog2n\n\n균형 이진탐색트리\n\navl트리\n\n---\n\n# [탐색3](https://www.smart.ac.kr/contents/LESSON_ONLY_1454/book/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_14_03.pdf)\n\n1. LL회전,RR회전,RL회전, LR회전\n\navl 트리구현\n\n2-3 트리\n\n234트리\n","lastmodified":"2023-06-10T09:18:39.924439352+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5-%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7":{"title":"컴퓨터 시스템","content":"\n### 과제\n\n|메인|과제|\n|------|------|\n|프로세스 개념을 설명하고 처리방식에 대해 설명하시오||\n\n### [.tar 아카이브와 jar 개념](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_09_01.pdf)\n\n**1. 파일아카이브 : tar**  \n - 중요한 파일이나 디렉토리는 데이터가 손상될 때를 대비해서 복사본을 만드는 것이 안전  \n - 아카이브 원래 의미 : 보관소, 저장소  \n - 유닉스에서의 의미 : 파일을 묶어 하나로 만든 것 \n\n﻿**2. 아카이브 생성하기 : cvf**  \n - tar 명령을 이용해 여러 파일이나 디렉토리를 묶어서 아카이브 파일을 생성할 수 있다. \n\n﻿**3. 아카이브 생성 확인 : tvf**  \n - 생성된 아카이브를 확인할 때에는 t(table of contents) 기능을 사용한다.  \n - v 옵션은 파일의 상세 정보를 보기 위해 지정하는 것이다. \n\n**4. 아카이브 풀기 : xvf**  \n - 아카이브를 풀 때에는 x(extract) 기능을 사용한다.  \n﻿ \n\n﻿**5. 아카이브 업데이트 하기: uvf**  \n - 아카이브를 만든 다음, 일부 파일 내용이 바뀌었다면 u(update)기능을 이용해 수정된 파일을 추가할 수 있다. \n\n﻿**6. 파일 추가하기: rvf**  \n - 이미 생성된 아카이브에 파일을 추가하는 기능은 r(replace)이다. \n\n※ u 기능은 아카이브에 파일이 이미 있는지 확인하고 추가하는 반면에, r 기능은 지정한 파일을 무조건 아카이브 마지막에 추가한다. \n\n﻿**7. jar(Java Archive Tool)**  \n - 여러 파일을 하나의 jar 아카이브 파일로 묶어 압축하는 명령이다.  \n - 자바 애플릿이나 애플리케이션을 하나의 아카이브로 묶기 위해 개발이 되었다.    \n※ jar 명령을 사용하기 위해서는 시스템에 jdk(Java Development Kit)가 설치되어 있어야 한다. \n\n﻿**8. 아카이브 생성과 압축하기: cvf**  \n - jar에서 압축된 아카이브 파일을 생성하는 옵션은 cvf 이다.  \n  · jar는 tar보다 시간이 오래 걸리기 때문에 많은 파일을 압축하는 경우, 작업이 중단된 것인지 판단하기 어려우므로 옵션 -v를 쓰는 것이 좋다. \n\n﻿**9. 아카이브만 생성하기: c0vf**  \n - jar  명령을 이용해 압축하지 않고 아카이브만 생성하는 옵션은 숫자 0을 이용한다. \n\n﻿**10. 아카이브 내용 보기: tvf**  \n - jar에서 압축된 아카이브 파일의 상세 정보를 보는 옵션은 tvf이다.  \n  · 아카이브에 포함된 파일의 이름만 출력된다. \n\n﻿**11. 아카이브 업데이트 하기 : uvf**  \n - 일부 파일 내용이 바뀌었다면 u(update) 옵션을 이용해 수정된 파일을 추가할 수 있다. \n\n﻿**12. 아카이브 풀기: xvf**  \n - jar의 압축 및 아카이브를 푸는 옵션은 xvf이며 tar와 같다.\n\n---\n\n### [z파일 pack/unpack compress/uncompress](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_09_02.pdf)\n\n**1. 파일 압축 : pack 특징**  \n - pack 명령은 확장자가 .z인 파일을 생성하는 압축 명령이다.  \n - tar와 jar와는 달리 파일을 묶지 않고 1대 1로 압축한다.  \n - 원본 파일을 남기지 않으며, 디렉토리는 압축하지 못한다.  \n - pack 명령은 별다른 실효성이 없는 작은 파일 같은 경우 압축하지 않는다.\n\n※ f 옵션을 이용해 압축하기  \n - 파일의 크기와 관계없이 무조건 압축해야 할 경우  \n  · pack 명령은 별다른 실효성이 없는 작은 파일 같은 경우 압축하지 않는다. \n\n﻿**2. 파일 내용 보기 : pcat**  \n - pcat 명령을 사용하면 압축을 풀지 않고도 압축된 파일의 내용을 볼 수 있다. \n\n﻿**3. 압축 풀기 : unpack**\n\n* pack 명령에 의해 압축된 파일에 대해 압축 해제할 수 있다. \n\n﻿**4. 압축하기 : compress**  \n - pack 명령보다 압축률이 더 높다. \n\n﻿**5. 파일 내용 보기 : zcat**  \n - zcat 명령을 사용하면 압축을 풀지 않고도 압축된 파일의 내용을 볼 수 있다. \n\n﻿**6. 압축 풀기 : uncompress**  \n - compress 명령으로 압축된 파일을 복원한다.\n\n---\n\n### [.gz파일 .bz2파일](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_09_03.pdf)\n\n**1. 압축하기 : gzip**  \n - gzip 명령은 지정한 파일을 압축해 “파일이름.gz\" 파일을 생성한다.  \n※ gzip은 다른 압축명령과 달리 별도의 압축풀기 명령을 사용하지 않고 d 옵션(gzip -d 1.txt.gz)을 이용해 압축된 파일을 복원 할 수 있다. \n\n﻿**2. 파일 내용 보기 : gzcat**  \n - 압축된 파일 내용을 볼 수 있다. \n\n﻿**3. 압축 풀기 : gunzip**  \n - gzip으로 압축한 파일은 gunzip으로 복원할 수 있다. \n\n﻿**4. 압축하기 : zip**  \n - 지정한 파일을 압축해 파일이름 .zip이라는 파일을 생성한다.  \n  · zip 명령도 tar 명령처럼 원본 파일은 그대로 두고 압축 파일을 별도로 만든다.  \n - PC의 zip과 호환이 가능하기 때문에 유닉스와 PC간에 데이터를 주고받을 때 사용한다. \n\n﻿**5. 압축풀기 : unzip**  \n - zip으로 압축한 파일을 해제할 수 있다. \n\n﻿**6. 압축하기 : bzip2**  \n - bzip2는 오픈소스 압축 명령으로 다른 압축 명령어에 비해 압축률이 좋지만 속도는 약간 느리다.  \n - 지정한 파일을 압축해 파일 이름 .bz2 파일을 생성한다. \n\n﻿**7. 파일 내용 보기 : bzcat**  \n -  bzip2로 압축한 파일 내용을 볼 수 있다. \n\n﻿**8. 압축풀기 : bunzip2**  \n -  bzip2로 압축한 파일을 해제할 수 있다.\n\n---\n\n### [사용자간 직접통신](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_10_01.pdf)\n\n**1. 로그인하고 있는 사용자들이 서로 직접 통신할 수 있는 명령 : write, wal, talk, mesg**  \n  · write, wall : 쪽지를 보내는 것처럼 다른 사용자에게 간단한 메시지를 보내는 것  \n  · talk : 채팅과 같은 기능으로 대화를 하는 것  \n  · mesg : 메시지 수신 여부를 설정하는 명령\n\n※ wall 명령을 사용하려는 사용자는 tty 그룹에 속해 있어야 한다. \n\n﻿**2. write 명령을 이용한 통신**  \n - write 명령은 지정한 사용자에게 메시지를 전송한다.  \n  · 메시지를 전달하려는 대상은 한 사용자에게만 전송할 수 있다. \n\n﻿**3. wall 명령을 이용한 통신**  \n - wall 명령은 유닉스에 로그인하고 있는 모든 사용자에게 메시지를 전송한다.  \n  · 전달하려는 메시지 내용을 파일로 작성해 놓았다면 파일명을 인자로 지정하면 된다. \n\n﻿**4. talk 명령을 이용한 통신**  \n - talk 명령은 일반 채팅 프로그램처럼 상대방과 일대일로 대화를 할 수 있는 기능을 제공한다. \n\n﻿**5. mesg 명령을 이용한 통신 제어**  \n - write, wall, talk 메시지를 단말기에 출력하는 것을 허용/금지 \n\n﻿**6. 메일 서버**  \n - 메일 서비스를 제공하는 프로그램 또는 그 프로그램이 실행중인 시스템  \n - POP3, SMTP 등 \n\n﻿**7. 메일 클라이언트**  \n - 메일 서비스를 요청하는 프로그램  \n - mailx(System V), mail(BSD), 아웃룩익스프레스 등 \n\n﻿**8. 도착한 메일은 자동적으로 기본 메일 박스에 저장된다.**  \n - user1의 경우 : /var/mail/user1 \n\n﻿**9. mailx 내부 명령** \n\n![](http://www.smart.ac.kr/contents/LESSON_ONLY_1461/28/data/S_LESSON_ONLY_1347_20171116164448.jpg)\n\n---\n\n### [메일관리 및 호스트와 개인정보 확인](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_10_02.pdf)\n\n**1. 메일 삭제하고 복구하기**  \n - 읽은 메일을 보관하지 않고 삭제하려면 d 명령을, 잘못 삭제한 메일을 복구하려면 u 명령을 사용한다. \n\n﻿**2. 호스트명 확인하기**  \n - 유닉스에서 자신의 호스트명을 확인할 때 사용하는 명령은 hostname 이다. \n\n﻿**3. IP 주소 검색하기**  \n - 인터넷으로 접속하는 사이트의 이름은 알고 있는데 해당 사이트의 IP 주소가 무엇인지를 검색할 때 nslookup 명령을 사용한다.  \n  · nslookup 명령은 DNS 서버에 접속하여 도메인명에 해당하는 IP 주소를 검색하거나 IP 주소에 해당하는 도메인명을 검색한다. \n\n﻿**4. 호스트 동작 확인하기**  \n - 다른 유닉스 호스트에 접속하려고 할 때, 상대방 호스트와 연결되는지 확인할 필요가 있을 때 ping 명령을 사용한다.  \n\n  · ‘... is alive\" 라고 출력되면 상대방 호스트와 연결이 되는 것으로, 텔넷이나 FTP 같은 다른 작업을 할 수 있다.  \n  · 만약, 상대방 호스트와 연결이 되지 않으면 “no answer from . .. \"과 같은 형태의 메시지를 출력한다. 이것은 상대방 호스트가 다운되어있거나, 네트워크에 이상이 있어 연결이 되지 않음을 의미한다. \n\n﻿**5. 개인 정보 확인하기**  \n - finger 명령은 사용자의 로그인 여부와 관계없이 개인정보를 확인할 수 있도록 해 준다.  \n - 사용자의 보다 상세한 정보를 보여주며 다른 호스트에 등록되어 있는 사용자의 개인정보도 확인 할 수 있다.  \n  · 현재 유닉스에 로그인하고 있는 사용자의 정보를 확인하는 명령으로는 w, who, id 등 있음. \n\n﻿﻿**6. 사용자의 상세 개인 정보 출력하기**  \n - finger의 인자로 사용자명을 지정하면 출력되는 사용자의 상세한 개인정보 목록  \n  · 로그인명  \n  · 사용자의 실명  \n  · 사용자의 홈 디렉토리  \n  · 사용자의 기본 쉘  \n  · 로그인한 시간과 단말기명, 접속한 외부 호스트의 주소  \n  · 메일  \n  · 특별한 계획 유무(스케쥴) : 사용자 홈 디렉토리의 .plan 파일에 기록된 내용\n\n---\n\n### [파일 송수신](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_10_03.pdf)\n\n**1. FTP(File Transfer protocol) 명령**  \n  · 인터넷을 통해 다른 시스템에 있는 파일을 내 시스템으로 가져오거나, 내 시스템에 있는 파일을 다른 시스템으로 보내야 할 경우  \n  · 유닉스간에 파일을 주고 받을 때, 유닉스와 윈도우간의 파일 송수신에도 사용 \n\n﻿**2. 로그인명을 이용한 FTP의 사용**  \n - ftp 명령을 사용하려면 상대방의 호스트명과 로그인명, 비밀번호를 알아야 한다. \n\n﻿**3. ftp 내부 명령** \n\n![](http://www.smart.ac.kr/contents/LESSON_ONLY_1461/30/data/S_LESSON_ONLY_1347_20171116172132.jpg) \n\n**4. 파일 송수신하기**  \n - ftp 명령으로 파일을 송수신할 때는 우선적으로 dir 또는 ls 명령으로 파일명을 확인하고  \n - get, mget, put, mput 명령으로 파일을 송수신한다.  \n  · 한 번에 한 개의 파일을 송수신할 때 : get, put 명령 사용  \n  · 한 번에 여러 개의 파일을 송수신할 때 : mget, mput 명령 사용\n\n※ mget과 mput 명령을 사용하면 각 파일을 전송할 것인지 여부를 매번 물어보는데 prompt 명령으로 이것을 설정하거나 해제할 수 있다. \n\n﻿**5. bye 명령의 사용 예**  \n - ftp 접속을 종료하는 명령은 bye 이다. \n\n﻿**6. 익명 ftp 사용**  \n - 익명 ftp란, FTP 서비스를 이용하는 경우 호스트에 등록된 로그인명을 몰라도 익명으로 ftp를 이용할 수 있도록 하는 것이다.  \n - 사용하는 로그인명은 anonymous이며, 비밀번호는 자신의 이메일 주소를 입력한다. \n\n※ 익명 ftp 서비스는 시스템 관리자가 이 서비스를 제공하도록 설정해 놓은 호스트만 서비스 제공이 가능하다.\n\n# [파일 및 파일 내용 검색](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_11_01.pdf)\n\nwc 명령, word count \n\ngrep, egrep (정규표현식)\n\n---\n\n# [파일 정렬과 분할](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_11_02.pdf)\n\nsort \n\nsplit\n\nuniq\n\n---\n\n# [필드 잘라내기와 파일 연결하기](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_11_03.pdf)\n\ncut - 엑셀처럼 자를 수 있음\npaste\ndd \n\n---\n\n# [유닉스 쉘 소개](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_12_01.pdf)\n\n쉘 동작 순서\n\n---\n\n# [콘쉘의 주요 기능](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_12_02.pdf)\n\nalias 만들기\nalias ls-'ls -F' \n\nunalias\n\nhistory\n\nr c\n\n.profile\n\n---\n\n# [c쉘의 주요기능](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_12_03.pdf)\n\n---\n\n# [쉘 스크립트와 쉘 변수](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_13_01.pdf)\n\n\n\n\n\n---\n\n# [연살자와 제어문if](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_13_02.pdf)\n\nread\nif\n\n---\n\n# [제어문 함수 디버깅](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_13_03.pdf)\n\ncase\nfor\nwhile\nuntil\nselect\ncontinue\n\nfunction\nreturn\n\n디버깅\nbash -x \ntarp\n\n---\n\n# [시스템관리자 역할 및 부팅과 종료](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_14_01.pdf)\n\n---\n\n# [사용자 및 그룹관리](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_14_02.pdf)\n\n로그인쉘 종류 바꿀려면 /etc/passwd 파일에서 수정하면 된다.\n\n---\n\n# [시스템 관리](https://www.smart.ac.kr/contents/LESSON_ONLY_1461/book/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C_14_03.pdf)\n\nroot 비밀번호 복구하는법\n","lastmodified":"2023-06-10T09:18:39.912063939+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/C%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5":{"title":"C언어","content":"\n### [함수의 기본 개념 이해](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_10_01.pdf)\n\n### [구조적 프로그래밍 순환함수와 함수포인터 그리고 메인함수](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_10_02.pdf)\n\n---\n\n# [구조체와 공용체의 개념](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_11_01.pdf)\n\n구조체는 데이터 타입임\n\n---\n\n# [구조체 심화 학습](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_11_02.pdf)\n\n구조체 배열\n\n---\n\n# [스트림과 파일 그리고 표준 입출력](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_12_01.pdf)\n\n---\n\n# [파일 입출력 함수](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_12_02.pdf)\n\n---\n\n# [선행처리 지시자](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_13_01.pdf)\n\n전처리기\n\nifdef\n\n매크로 함수, 변수\ndefine\n\n---\n\n# [사용자 라이브러리 파일 만들기](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_13_02.pdf)\n\n---\n\n# [표준 라이브러리 함수](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_14_01.pdf)\n\n표준 라이브러리 파일들\n\n문자, 자료 변환함수\n\n시간 관련함수\n\n---\n\n# [수학 관련 함수](https://www.smart.ac.kr/contents/LESSON_ONLY_1434/book/C%EC%96%B8%EC%96%B4%E2%85%A0_14_02.pdf)\n\n삼각함수\n","lastmodified":"2023-06-10T09:18:39.908620294+09:00","tags":[]},"/%E1%84%89%E1%85%AE%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A2/Wifi":{"title":"Wifi","content":"\n# **wpa_supplicant에 대해서 자세히 써넣은 내용**\n\n \u003e \n \u003e * 필요한 소프트웨어  \n \u003e   wireless-tools, wpa_supplicant, dhcpcd\n\n---\n\n## iwconfig 명령으로 사용 가능한 무선랜 카드 장치 이름 확인할 수 있다.\n\n````\n$ iwconfig  \n````\n\nno wireless extensions.\n\nwlan0 IEEE 802.11bgn Mode:Managed Access Point: Not-Associated  \nTx-Power=0 dBm  \nRetry long limit:7 RTS thr:off Fragment thr:off  \nEncryption key:off  \nPower Management:off\n\nsit0 no wireless extensions.\n\neth0 no wireless extensions.\n\n---\n\n## 유선 랜 장치를 비활성화하고 무선 랜 장치를 활성화 한다.\n\n````\n$ ifconfig eth0 down  \n$ ifconfig wlan0 up\n````\n\n \u003e \n \u003e 연결 가능한 무선 공유기의 ssid 이름 및 무선 보안 여부를 확인해야 함.\n\n````\n$ iwlist wlan0 scanning  \n````\n\n…………………..  \nEncryption key:on \\\u003c-- 무선 보안 사용 중임 \nESSID:\"ssid_name\" \\\u003c-- ssid 이름\nIE: WPA Version 1 \\\u003c-- 무선 보안 정보\nGroup Cipher : CCMP \nPairwise Ciphers (1) : CCMP \nAuthentication Suites (1) : PSK \nIE: IEEE 802.11i/WPA2 Version 1 \nGroup Cipher : CCMP \nPairwise Ciphers (1) : CCMP \nAuthentication Suites (1) : PSK \n....................... \n\\\u003ewpa_supplicant 명령을 사용하려면 wpa_supplicant.conf가 필요하다. 이를 위해 우선 psk키를 생성한다. \n\n````\n$ wpa_passphrase ssid_name \u003e /etc/wpa_supplicant/wpa_supplicant.conf  \n````\n\npassword 입력 후 엔터\n................................\n\n \u003e \n \u003e 입력한 password가 psk로 바꿔어 진 것을 확인 할 수 있다.\n\n````\n$ cat /etc/wpa_supplicant/wpa_supplicant.conf  \n````\n\n................................... \nreading passphrase from stdin  \nnetwork={  \nssid=”ssid_name”  \npsk=”입력한 password”  \npsk=”생성된 psk”  \n}\n................................\n\n \u003e \n \u003e 생성된 파일 wpa_supplicant.conf에 추가 정보를 입력한다.\n\nreading passphrase from stdin  \nnetwork={  \nssid=”ssid_name”  \nproto=WPA  \nkey_mgmt=WPA-PSK  \npairwise=CCMP  \ngroup=CCMP  \npsk=”생성된 psk”  \n}\n\n \u003e \n \u003e 유선 랜 장치를 중지시키고\n\n````\n$ ifconfig eth0 down\n````\n\n \u003e \n \u003e 무선 랜 장치를 활성화 한다.\n\n````\n$ ifconfig wlan0 up\n````\n\n \u003e \n \u003e ssid가 ssid_name인 공유기에 연결한다\n\n````\n$ iwconfig wlan0 essid “ssid_name”  \n$ wpa_supplicant -iwlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf \u0026  \n````\n\n\\[1\\] 1920  \nCTRL-EVENT-SCAN-RESULTS  \nTrying to associate with 00:00:00:00:00:00 (SSID=’ssid_name’ freq=2412 MHz)  \nAssociated with 00:00:00:00:00:00  \nWPA: Key negotiation completed with 00:00:00:00:00:00 \\[PTK=CCMP GTK=CCMP\\]  \nCTRL-EVENT-CONNECTED – Connection to 00:00:00:00:00:00 completed (auth) \\[id=0 id_str=\\]\n\n \u003e \n \u003e ip를 dhcp로 할당 받는다\n\n````\n$ dhcpcd wlan0 \u0026  \n````\n\n\\[2\\] 1923  \nwlan0: dhcpcd 4.0.15 starting  \nwlan0: broadcasting for a lease  \nwlan0: offered 192.168.0.2 from 192.168.0.1  \nwlan0: acknowledged 192.168.0.2 from 192.168.0.1  \nwlan0: checking 192.168.0.2 is available on attached networks  \nwlan0: leased 192.168.0.2 for 864000 seconds\n\n \u003e \n \u003e ?또는 수동으로 ip를 설정하려면\n\n````\n$ ifconfig wlan0 192.168.0.10 netmask 255.255.255.0 broadcast 192.168.0.255  \n$ route add default gw 192.168.0.1 wlan0  \n$ echo nameserver 192.168.0.1 \u003e /etc/resolv.conf \n````\n\n\\\u003c--DNS 서버 설정 인터넷 사용가능 여부 테스트 $ ping google.com PING google.com (74.125.127.147) 56(84) bytes of data. 64 bytes from pz-in-f147.1e100.net (74.125.127.147): icmp_seq=1 ttl=48 time=135 ms 참고 Wireless LAN with WPA (AES) http://www.izawalab.com/blog/?p=622 Gentoo Linux x86 Handbook http://www.gentoo.org/doc/en/handbook/h ... t=4\u0026chap=4\n\n# UPNPC\n\n \u003e \n \u003e 포트포워딩 등록\n\n````\n$ upnpc -a \u003c내부 IP 주소\u003e \u003c외부포트번호\u003e \u003c방식 (TCP,UDP)\u003e\n````\n\n \u003e \n \u003e 포트포워딩 삭제\n\n````\n$ upnpc -d \u003c외부포트번호\u003e\n````\n\nupnpc -a ip port external_port tcp | udp # Add port mapping\nupnpc -d external_port tcp | udp         # Delete port mapping\nupnpc -e \\[ip\\]                            # External IP address\nupnpc -i \\[msec\\]                          # Initialize device list\nupnpc -g \\[ip\\]                            # Gateway status\nupnpc -n \\[ip\\]                            # Get model name\nupnpc -s \\[ip\\]                            # Device status\nupnpc -l                                 # List port mappings\nupnpc -r port1 tcp | udp \\[...\\]           # Map these ports to the host interface\n","lastmodified":"2023-06-10T09:18:39.910205759+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%86%E1%85%AF%E1%84%80%E1%85%A1-%E1%84%8B%E1%85%A1%E1%84%85%E1%85%B3%E1%86%B7%E1%84%83%E1%85%A1%E1%86%B8%E1%84%83%E1%85%A1%E1%84%80%E1%85%A9-%E1%84%82%E1%85%B3%E1%84%81%E1%85%B5%E1%84%82%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A1":{"title":"뭐가 아름답다고 느끼는가","content":"\n### 날짜 : 2022-09-26 19:17\n\n### 주제 : #logic #규칙 #아름다움 #익숙함 #변화 #뇌\n\n---\n\n### 메모\n\n \u003e \n \u003e 평균에서 조금 다른걸 사람들은 아름답다 한다.\n\n🤔 다른 말로 하면 많이 봐서 \\*\\*\u003cu\u003e익숙\u003c/u\u003e\\*\\*하면서도 조금 달라 \\*\\*\u003cu\u003e새로운 것\u003c/u\u003e\\*\\*이면 아름답게 느끼는 것 아닐까?\n\n### 출처(참고문헌)\n\n* [김풍x장동선 유튜브](https://youtu.be/SNIGKSzo6bo) 11:50\n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.908328161+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%89%E1%85%A1%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%B3%E1%86%AF%E1%84%81%E1%85%B5%E1%84%85%E1%85%B5-%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A2%E1%84%80%E1%85%A1%E1%86%B7%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%8A%E1%85%A1%E1%87%82%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8":{"title":"사람들끼리 유대감을 쌓는 방법","content":"\n### 📅날짜 : 2022-10-22 15:15\n\n### 주제 : #커뮤니티 #공감 #유대감\n\n---\n\n### ✒️메모\n\n \u003e \n \u003e #### 예상 : 커뮤니티 안에서 어떤 사건이 일어날 때 마다 커뮤니티에 유대감은 늘어난다.\n\n아파트 엘리베이터에 ❗==유기견 출몰==❗이라는 공지가 붙었다.\n\n* 이런 사건이 많으면 많을 수록 아파트 커뮤니티에 사람들간에 유대감이 많이 생겨나지 않을까?\n\n### 📄출처(참고문헌)\n\n* 나\n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.912644915+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8":{"title":"실력","content":"\n### 📅날짜 : 2022-11-06 21:32\n\n### 주제 : #통찰력 #미래 #리더\n\n---\n\n### ✒️메모\n\n \u003e \n \u003e #### 나이가 들어서 실력 있는사람은 통찰력이 뛰어난 사람.\n\n내가 어떤 사람을 따를 지 말지 🎲결정할 때는 그사람의 통찰력을 보고 결정하자.\n\n그사람의 🌎️세계관, 🔍️가치관 등이 나랑 맞는지 확인하는게 필요해.\n\n디테일, 기술적 뛰어남은 젊은 사람이 더욱 뛰어난게 맞을지도?\n나이가 들면 새로운걸 배우는것이 어려운 사람이 대부분.\n\n상대방의 세계관, 통찰력은 그 근거들을 듣고 기억만 해두고 그것이 바로 사실이야! 라고 하진 않는것이 좋을듯 하다.\n\n#### 어떻게 하면 통찰력을 키울 수 있지?\n\n---\n\n### 📄출처(참고문헌)\n\n* 건아쌤 과의 대화 \n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.90920327+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%8B%E1%85%A5%E1%84%84%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%92%E1%85%A2%E1%84%8B%E1%85%A3%E1%84%92%E1%85%A1%E1%86%AF%E1%84%81%E1%85%A1__%E1%84%8B%E1%85%B5%E1%84%86%E1%85%A5%E1%86%AF%E1%84%8C%E1%85%A7%E1%86%AB":{"title":"어떤일을 해야할까__이멀젼","content":"\n### 🗓️날짜 : 2022-09-27 07:56\n\n### 주제 : #감정 #motivation  #만족감 #충족감 #내면의소리 #직관\n\n---\n\n### ✒️메모\n\n \u003e \n \u003e #### 각자마다 즐거움을 느끼는 일이 존재한다 생각한다\n\n직관적으로 느끼는 뇌의 만족도를 이멀젼 이라는 지표로 측정이 가능하다는데 사실일까?\n\u003cbr\u003e\n\n#### 보자마자 ️이거야 ❗라고 할떄\n\n* 어떠한 광고를 보고 그 제품에 대한 인상이 시작하고 몇초 이내로 결정이 된다 하는데, 그걸 다른 말로는 ==직관==적으로 봤을때 맘에든다 ,혹은 이 유튜브 에서는 ==이멀젼== 이 높아졌다 라고 이야기한 것 같다.\n\n이멀젼이 높은지 알 수 있는방법은\n\n1. 집중력이 유지 되는가\n1. Emotional resonance (감정이 동요 되는가)\n   예를 들면, 내가 일에 집중하고 있고 감정이 동요되면 이멀젼이 높다 한다.\n\n \u003e \n \u003e #### 그렇다면 어떤 일을 해야하는가.\n\n \u003e \n \u003e 어떤 일 보다는 어떻게 일을 해야 하는가 아닐까?\n\n위에서는 제품을 예시로 들었지만 대상을 ==일==로 바꾼다면,\n\n### \u003ccenter\u003e - 어떤 일을 하는데 이멀젼이 높아지는 일을 하면 된다\u003c/center\u003e\n\n\u003ccenter\u003e=\u003e 집중력이 유지되고 감정적으로 고조되는 일을 하면된다.\u003c/center\u003e\n\u003cbr\u003e\n\n~~뭔가 당연한 말을 되게 거창하게 쓴거같은 기분이랄까..~~\n\n다시 읽으면서 중요한 부분이다 생각한건 \n\n \u003e \n \u003e  \u003e \n \u003e  \u003e ==**사람들은 판단을 굉장히 빨리한다.**==\n\n---\n\n### 📄출처(참고문헌)\n\n* [이리엘-인간의 뇌는 83~97% 잘될것을 예측할 수 있다](https://youtu.be/icrEf40hXMY)\n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.908831592+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%8B%E1%85%A5%E1%84%84%E1%85%A5%E1%87%82%E1%84%80%E1%85%A6-%E1%84%92%E1%85%A2%E1%84%8B%E1%85%A3-%E1%84%8C%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AF-%E1%84%89%E1%85%AE-%E1%84%8B%E1%85%B5%E1%86%BB%E1%84%82%E1%85%A1":{"title":"어떻게 해야 집중할 수 있나","content":"\n### 날짜 : 2022-09-28 07:42\n\n### 주제 : #행동 #motivation #뇌 #불편함\n\n---\n\n### 메모\n\n \u003e \n \u003e #### 사람은 불편함을 피하기 위해서 행동한다.\n\n* 추운걸 피하려고 옷을 입고, 배고픔을 견디려고 밥을 먹고, (생리적 감각)\n\n* 외로울땐 페이스북을 보고, 지루하면 유튜브나 스포츠를 찾아보고 (심리적 감각)\n\n만일 위 인용이 사실이면 ==시간관리 = 고통관리== 이다\n\n🧠뇌가 잘하는건 **패턴**◾️◽️◾️◽️을 찾는것이다.\n불편함을 느끼면 여러가지 행동들을 해보고 불편함이 사라지는걸 경험하면 **\u003cu\u003e그 행동이 습관을 형성한다\u003cu\u003e**\n\n#### 불편함을 해소하는방법\n\n1. 불편함을 만드는 근원을 고친다.\n   \n   * 고통을 주는 무언가를 바꾸는 것\n1. 불편함을 대체할 전술이 필요하다.\n   \n   * 감정에 반응하는 방법을 바꾸는 것\n     \\\u003e엄격한 자제는 오히려 역효과를 일으킨다.\n     \n     예를 들어 🚬담배는 그자체로 기분좋음을 일으키는게 아닌, 피지말자 피지말자 하다가 다시 폈을때, 즉 참고있던 불편함을 벗어나는 느낌에 중독 되는것이다.\n   \n   * 대처방법\n     \\\u003e불편감이 올라올때 **\u003cu\u003e10분을 기다리면\u003c/u\u003e** 된다.\n     \n     결국엔 불편함도 감정이기에 감정에 파도를 이용하는 것이다.\n     \n     10분 동안은 그 불편함에 호기심을 가지고 왜 나는 지금 그 불편함을 느끼는지를 물어보거나, 하던일에 집중해서 10분을 보내보자\n\n \u003e \n \u003e #### 집중하는 방법\n\n내가 하고자 하는 **일** 이 나의 어떤 ==불편함을 해소== 할 수 있는 방향으로 연결 시켜 주면 된다.\n\n(나중에 사례가 생기면 적어보자.)\n\n### 출처(참고문헌)\n\n* [10분만 참으면 뇌에서 일어나는 변화](https://youtu.be/a5CC8rwOyt8)\n\n### 연결문서\n\n* [어떤일을 해야할까__이멀젼](%E1%84%8B%E1%85%A5%E1%84%84%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%92%E1%85%A2%E1%84%8B%E1%85%A3%E1%84%92%E1%85%A1%E1%86%AF%E1%84%81%E1%85%A1__%E1%84%8B%E1%85%B5%E1%84%86%E1%85%A5%E1%86%AF%E1%84%8C%E1%85%A7%E1%86%AB.md)\n","lastmodified":"2023-06-10T09:18:39.912268362+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%83%E1%85%A1%E1%86%AF%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8":{"title":"정보전달방법","content":"\n### 📅날짜 : 2022-10-12 23:47\n\n### 주제 : #대화 #소통 #설득\n\n---\n\n### ✒️메모\n\n \u003e \n \u003e 상대방이 보는것 처럼 상상 할 수 있게끔 말해야 한다.\n\n100만분의 1, 30km 등의 정보를 들으면 그걸 머리속으로 그리기는 힘들다.\n\n5cm정도의 종양 대신에 달걀크기에 종양 이라고 말하는 것 처럼, 상대방이 머리속에 그릴 수 있도록 하는것이 중요하다.\n\n‐------\n\n꼭 비유뿐만 아니라 어떤 정보 전달에도 머리속으로 그릴 수 있으면 좋지 않을까?\n\n### 📄출처(참고문헌)\n\n* 도서 - 넘버스 스틱\n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.909164977+09:00","tags":[]},"/%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%80%E1%85%AE%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3/%E1%84%8C%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8-%E1%84%8E%E1%85%A1%E1%86%BD%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%89%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5":{"title":"직업 찾는 순서","content":"\n### 날짜 : 2022-10-03 00:35\n\n### 주제 : #직업 #천직 #좋아하는일 #예상\n\n---\n\n### 메모\n\n \u003e \n \u003e 좋아하는 일을 찾는 순서가 있지 않을까?\n\n##### 여러가지 것들을 경험한다.\n\n* 이것 저것 해보면서 내가 뭘 좋아하는지 어떤걸 싫어하는지 왜 좋아하는지 등을 ==파악==한다.\n* 목적은 정말 내가 좋아하는 일 이 눈앞에 등장했을때 올바른 ==판단==을 할 수 있게끔 (그것을 선택 하는것)\n\n##### 좋아하면서 잘하는 일을 찾고 경험을 쌓는다.\n\n* 어느 단계 까지 해야하는지는 모르지만 그래도 꽤 긴 시간 (2-3년?) 동안 ==경험==하고 ==스킬==들을 쌓아 나가는 시간.\n* 좋아하는일 이기때문에 집중하기도 쉬울꺼고 잘하면 재밌어서 더 열심히 하게 되지 않을까?\n* 물론 주변에서 잘한다는 칭찬도 필요하고 지속할 수있는 환경도 중요할것 같다.\n\n##### 집중하는 분야를 찾게 된다.\n\n* 좋아하는 일을 가지고 어떤 분야, 더 정확히 말하면 ==특정한 '일'==을 하면서 ==돈을 벌고 만족감==을 느끼는 시기 \n* 세상에 해결되지 않은 문제나 아직 발견되지 않은 분야, 가능성이 많은 분야 를 찾게 되는거지 않을까?\n\n###### 그다음은?\n\n* 남에게 도움을 주는 단계 일까?\n* 또 다른 새로운 분야일까?\n* 찾은 분야를 확장하는 단계 일까?\n* 아에 새로운 것 일지도.\n\n \u003e \n \u003e 포인트는 ❓억지로 막 찾으려 할 필요가 있나? 라는 생각\n\n---\n\n### 출처(참고문헌)\n\n* 임지연 이예진과의 대화\n\n### 연결문서\n\n* \n","lastmodified":"2023-06-10T09:18:39.909774496+09:00","tags":[]},"/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/%E1%84%8B%E1%85%A9%E1%86%AB%E1%84%89%E1%85%B3%E1%86%B8%E1%84%83%E1%85%A9-%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5-%E1%84%8E%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5":{"title":"온습도 데이터 측정하기","content":"\n알리 익스프레스를 기웃거리다 CO2 센서가 있길래 2개 사봤다\n\n|||\n|::|::|\n|scd4x|Wemos d1 mini (esp8266)|\n\n### 조립\n\n#### 점퍼선 연결\n\n* PIN \\#G - 센서 GND\n* PIN \\#3v3 – 센서 VDC\n* PIN \\#D2 – 센서 SDA\n* PIN \\#D1 - 센서 SCL\n\n### 작동 방법\n\n* 5분마다 센서가 온도, 습도, 이산화탄소를 측정해서  Json 포맷으로 서버에 전달한다.\n* 서버는 데이터를 받으면 보기 편하게 파일로 저장한다.\n\n---\n\n \u003e \n \u003e 클라이언트 (아두이노)\n\n````C\n#include \u003cSensirionI2CScd4x.h\u003e\n#include \u003cWire.h\u003e\n#include \u003cESP8266WiFi.h\u003e\n#include \u003cESP8266HTTPClient.h\u003e\n#include \u003cWiFiClient.h\u003e\n\nSensirionI2CScd4x scd4x;\n\nconst char* ssid = \"HelloWorld\";\nconst char* password = \"sangyeon\";\n\nconst char* serverName = \"YOUR SERVER ADDRESS\";\n\n  \n\n// the following variables are unsigned longs because the time, measured in\n// milliseconds, will quickly become a bigger number than can be stored in an int.\nunsigned long lastTime = 0;\n// Timer set to 10 minutes (600000)\n//unsigned long timerDelay = 600000;\n// Set timer to 5 seconds (5000)\nunsigned long timerDelay = 300000; // 5 min\n\n  \nvoid setup() {\n  Serial.begin(115200);\n\n  WiFi.begin(ssid, password);\n  Serial.println(\"Connecting\");\n\n  while(WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.print(\"Connected to WiFi network with IP Address: \");\n\n  Serial.println(WiFi.localIP());\n  Serial.println(\"Timer set to 5 seconds (timerDelay variable), it will take 5 seconds before publishing the first reading.\");\n}\n\nvoid loop() {\n  //Send an HTTP POST request every 5 minutes\n\n  if ((millis() - lastTime) \u003e timerDelay) {\n\n    //Check WiFi connection status\n    if(WiFi.status()== WL_CONNECTED){\n\n      Wire.begin();\n      scd4x.begin(Wire);\n      scd4x.stopPeriodicMeasurement();\n      scd4x.startPeriodicMeasurement();\n\n      uint16_t error;\n      char errorMessage[256];\n\n      delay(5000);\n\n      // Read Measurement\n      uint16_t co2;\n      float temperature;\n      float humidity;\n\n      error = scd4x.readMeasurement(co2, temperature, humidity);\n\n      if (error) {\n          Serial.print(\"Error trying to execute readMeasurement(): \");\n          errorToString(error, errorMessage, 256);\n          Serial.println(errorMessage);\n\n      } else if (co2 == 0) {\n          Serial.println(\"Invalid sample detected, skipping.\");\n\n      } else {\n      WiFiClient client;\n      HTTPClient http;\n\n      // Your Domain name with URL path or IP address with path\n      http.begin(client, serverName);\n      http.addHeader(\"Content-Type\", \"application/json\");\n      int httpResponseCode = http.POST(\"{\\\"Temp\\\": \"+String(temperature)+\", \\\"Humi\\\": \"+String(humidity)+\",\\\"CO2\\\":\"+co2+\"}\");\n\n      Serial.print(\"HTTP Response code: \");\n      Serial.println(httpResponseCode);\n\n      http.end();\n      }\n    }\n    else {\n      Serial.println(\"WiFi Disconnected\");\n    }\n\n    lastTime = millis();\n  }\n}\n````\n\n \u003e \n \u003e 서버 php 코드 \n\n````php\n\u003c?php\n$data = json_decode(file_get_contents('php://input'),true);\n$date = date(\"d\");\n\n$filedate = date(\"Y-m\");\n$file = json_decode(file_get_contents('YOUR LOCATION'.$filedate),true);\n\n\nif (empty($file)){\n  $file[$date] = [[date(\"H:i\") =\u003e $data]];\n} else {\n  array_push($file[$date], [date(\"H:i\") =\u003e $data]);\n}\n\n\nfile_put_contents('YOUR LOCATION'.$filedate, json_encode($file, JSON_PRETTY_PRINT));\n?\u003e\n````\n\n---\n\nC 랑 C++ 는 잘 몰라서 아두이노 라이브러리 이것저것 조합해서 일단 작동만 되도록 만들었다.\n\n\n\n\n","lastmodified":"2023-06-10T09:18:39.917610481+09:00","tags":[]},"/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/%E1%84%8B%E1%85%B1%E1%84%82%E1%85%A2%E1%84%89%E1%85%B5%E1%84%80%E1%85%A7%E1%86%BC-GUI":{"title":"위내시경 GUI","content":"\n\n\n### Entry point\n\n디자인과 ai모델이 있는 상황에서 개발 시작\n\n개발환경 : Python\n\n# 구조\n\n\n\\\u003e설명 \n\nControler 클래스에서 Login\u0026out을 관리한다.\n각각의 GUI 에선 정해진 로직을 처리하고 Controler 에 시그널을 보내는 형태이다.\n\n컨트롤러는 시그널에 따라 Login GUI 또는 Main GUI 를 보여준다.\n\n \u003e \n \u003e 이유\n\n처음엔 로그인 성공시 Login GUI 위에 Main GUI 를 띄우는 형식이였는데,\nLogin GUI 가 계속 백그라운드에서 떠있다보니 실행파일을 만들면 창이 2개가 뜨는 상황이 일어났다.\n\n# 주요기능\n\n### 메인화면\n\n\n\n \u003e \n \u003e 설명\n\n①   📷카메라 영상이 실시간으로 보여진다. \n\n* 크롭을 통해 원하는 부분만 선택해 보이게 할 수 있다.\n\n② 여러가지 설정할 수 있는 🕹️버튼들이 있다.\n\n* AI 버튼 클릭시 내시경 영상을 ai 를 통해 분석한다. (결과 사진 저장)\n* REC 버튼 클릭시 영상을 저장한다.\n\n### 파이프를 통해 데이터 송수신\n\n\n\\\u003e설명\n\n영상 저장과 AI분석은 프로세스를 나누었다.\n다른 프로세스에 통신을 위해 파이프를 통해 데이터를 주고 받았다.\n\n \u003e \n \u003e 이유\n\n한개의 프로세스로 실행하니 영상이 15프레임 정도까지 떨어져 성능개선을 위해 멀티 프로세스 사용\n프로세스를 나눈후 녹화된 영상으로 실행했을때 50-60프레임정도가 나왔다.\n\n큐를 통해 데이터 전송을 하다가 아에 새로운 파일로 모듈들을 분리하자는 의견이 있어 파이프를 사용했다.\n\n소켓도 고려했지만 파이프가 전송속도가 더 빠를것 같아 파이프 사용\n\n#### 레코드 모듈\n\n\n\\\u003e설명\n\n레코드 모듈에선 파이프로 이미지를 받아서 저장한다.\n멀티프로세스를 통해, 하나는 이미지를 받아서 큐에 저장하는 형태로, 다른 하나는 큐에서 이미지를 꺼내와서 파일을 만드는 형태이다.\n\n \u003e \n \u003e 이유\n\n파이프가 양쪽이 동기화가 되어있는지 한쪽에서 받은 데이터를 읽지 않으면 다음을 전송을 안해서 큐를 추가적으로 사용했다.\n\n#### AI 모듈\n\n\n\n \u003e \n \u003e 설명\n\n레코드 모듈과 비슷한 형태이지만 다른점은 다시 메인  GUI 에 결과값을 보내줘야한다는 점이다. \n똑같이 프로세스를 하나 더만들고 큐를 사용했다. 다만 AI결과를 위한 큐까지 총 AI 모듈에선 2개의 큐를 사용.\n\n \u003e \n \u003e 이유\n\n레코드 모듈과 동일하다.\n\n---\n\n## 부가기능\n\n### Config\n\n글자크기, 선 색 등 여러가지 설정정보 변경 가능\n\n### New Patient\n\n새로운 환자번호를 입력하면 초기화 + 새로 데이터 저장 시작\n\n### 사이버 보안원칙\n\n사이버 보안원칙에 따라, 사용자 아이디 비밀번호 암호화, 로그아웃, 파일 변경 감지 등 의 기능 추가\n","lastmodified":"2023-06-10T09:18:39.917181384+09:00","tags":[]},"/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/Hithere-app":{"title":"Hithere - app","content":"\n---\n\n# firebase 연결 + google login\n\n[유튜브 참고 영상](https://youtu.be/Y0IKGgBM8zo)\n\nCreate flutter project\n\n````shell\n# flutter create --org \u003corganization\u003e \u003cproject name\u003e\n$ flutter create --org com.hithere hithere_login\n````\n\n[Fire base](https://console.firebase.google.com/?hl=ko) 접속 후 프로젝트 추가\n\n프로젝트 생성 후\n-\u003e \n\n### 플러터 앱에 파이어 베이스 추가\n\n````\nFirebase Cli 설치 및 로그인\nFlutter sdk 설치\nFlutter create\n````\n\n````shell\n$ dart pub global activate flutterfire_cli\n\n# flutterfire configure --project= \u003cproject name\u003e\n$ flutterfire configure --project=hithere-login-4b114\n````\n\n안드로이드와 ios 체크\n\n### 안드로이드 앱에 파이어 베이스 추가\n\n\n\nandroid/app/build.gradle -\u003e applicationId 가 패키지 이름이다.\n\n[Keytool 사용 방법](https://developers.google.com/android/guides/client-auth?hl=ko) 을 통해 해시값 가져오기\ngoogle-services.json 다운로드 후 android/app/ 폴더에 덮어쓰기\n순서대로 Firebase SDK 추가\n\nandroid/app/build.gradle 파일\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n    minSdkVersion flutter.minSdkVersion  \n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\nminSdkversion 값 19로 변경\nmultiDexEnabled true -\u003e 추가\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n\tmultiDexEnabled true\n    minSdkVersion 19\n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\n### ios 세팅\n\n\\[project name\\]/ios 폴더에서 `pod install` 명령어 실행\n\n[pub.dev google_sign_in ](https://pub.dev/packages/google_sign_in)\n\nGoogleService-Info.plst 파일을 가져와 복사 했으면 \n위 링크에서 \n\n````\n\u003c!-- Put me in the [my_project]/ios/Runner/Info.plist file --\u003e\n\u003c!-- Google Sign-in Section --\u003e\n\u003ckey\u003eCFBundleURLTypes\u003c/key\u003e\n\u003carray\u003e\n\t\u003cdict\u003e\n\t\t\u003ckey\u003eCFBundleTypeRole\u003c/key\u003e\n\t\t\u003cstring\u003eEditor\u003c/string\u003e\n\t\t\u003ckey\u003eCFBundleURLSchemes\u003c/key\u003e\n\t\t\u003carray\u003e\n\t\t\t\u003c!-- TODO Replace this value: --\u003e\n\t\t\t\u003c!-- Copied from GoogleService-Info.plist key REVERSED_CLIENT_ID --\u003e\n\t\t\t\u003cstring\u003ecom.googleusercontent.apps.861823949799-vc35cprkp249096uujjn0vvnmcvjppkn\u003c/string\u003e\n\t\t\u003c/array\u003e\n\t\u003c/dict\u003e\n\u003c/array\u003e\n\u003c!-- End of the Google Sign-in Section --\u003e\n````\n\n이 부분을 Info.plist 에 붙여넣기 후 \n`com.googleusercontent.apps` 뒷부분에 내용을 GoogleService-Info.plist 파일에서 가져와서 붙여넣기한다.\n\n### flutter package 설치\n\n[firebase_core](https://pub.dev/packages/firebase_core/install)\n[firebase_auth](https://pub.dev/packages/firebase_auth/install)\n[google_sign_in](https://pub.dev/packages/google_sign_in/install)\n\\\u003c프로젝트명\u003e/pubspec.yaml\n\n````yaml\ndepemdencies:\n...\nfirebase_auth: ^4.2.9  \nfirebase_core: ^2.6.1  \ngoogle_sign_in: ^6.0.2\n````\n\n추가후 \n\n````shell\nflutter pub get\n````\n\n23.03.14 실행확인\n\n---\n\n# Facebook login\n\n[유튜브 참고 영상 링크](https://youtu.be/tPpFp9LFGgE)\nfacebook developer 에서 앱만들기\n설정 -\u003e 기본설정 탭\n앱 ID , 앱 시크릿 코드 파이어 베이스에 붙여넣기\n\n파이어베이스에서 리디렉션 URI 를 페이스북에 붙여넣기\n\n\n페이스북 빠른시작 탭에서 앱 설정\n\n순서대로 진행\n\n6. 리소스 및 메니페스트 수정 탭 에서\n   선택 사항) [광고 ID 권한](https://developers.facebook.com/docs/android/getting-started#ad-id-permissions)을 옵트아웃하려면 `uses-permission` 요소를 `application` 요소 뒤의 매니페스트에 추가합니다. \n   -\u003e 추가 안함\n\n### flutter package 설치\n\n\\\u003c프로젝트명\u003e/pubspec.yaml\n\n````yaml\ndepemdencies:\n...\nflutter_facebook_auth: ^3.5.0\n````\n\n````shell\nflutter pub get\n````\n\nfacebook auth 버전때문에 minSdkVersion 을 21로 변경\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n\tmultiDexEnabled true\n    minSdkVersion 21\n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\n# Graphql  사용하기\n\n````\ndependencies:\n\tgraphql: ^5.1.3\n````\n","lastmodified":"2023-06-10T09:18:39.917551021+09:00","tags":[]},"/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/Hithere-web":{"title":"Hithere - web","content":"\n/all 페이지 테스트 목록\n랜딩 - \n상단 검색 아이콘 버튼, \n중간 커리어 라이프 카테고리 리스트,\n모든 호스트 보기,\n밑 슬라이드 모든호스트 보러가기\n\nall -\nPC\n- 카테고리 클릭\n- 검색\n- 초기화\n- 더보기 클릭\n-검색\n- 카테고리 클릭\n- 취소\n- (검색결과 있을때 \u0026 없을때)\n- 호스트 시작하기 버튼 클릭 (become-host 페이지)\n모바일\n-검색\n- 카테고리 클릭\n- 취소\n- (검색결과 있을때 \u0026 없을때)\n- 필터 클릭\n- 카테고리클릭\n- 더보기 클릭\n- 필터 초기화\n- 바깥 회색부분 클릭\n- 카테고리 추가된 상태에서 검색 (초기화 확인)\n- 호스트 시작하기 버튼 클릭 (become-host 페이지)\n","lastmodified":"2023-06-10T09:18:39.908045985+09:00","tags":[]},"/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/MQTT-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5":{"title":"MQTT 사용하기","content":"\nmosquitto 설치\n\n````shell\nsudo apt-get intsall mosquitto\n````\n\n포트 확인 \n\n````shell\nsudo lsof -i -P -n\n````\n\n````\nmosquitto 4301 mosquitto    5u  IPv4  53131      0t0  TCP 127.0.0.1:1883 (LISTEN)\nmosquitto 4301 mosquitto    6u  IPv6  53132      0t0  TCP [::1]:1883 (LISTEN)\n````\n\nlocal host 에서만 연결가능해서\n\n/etc/mosquitto/conf.d/mosqquitto.conf 파일에 \n\n````\nlistener 1883\nallow_anonymous true\n````\n\n내용 추가\n\n---\n\nesp8266 샘플코드\n\n````c++\n#include \"Adafruit_SHT31.h\"\n#include \u003cESP8266WiFi.h\u003e\n#include \u003cPubSubClient.h\u003e\n\n\n#define wifi_ssid \"HelloWorld\"\n#define wifi_password \"sangyeon\"\n\n#define server \"192.168.10.101\"\n#define mqtt_user \"\"\n#define mqtt_password \"\"\n\n#define THREE_SECONDS 3000\n\n\nAdafruit_SHT31 sht31 = Adafruit_SHT31();\n\n\nunsigned long current_time;\nunsigned long last_run = 0;\nchar temp[10];\nchar humi[10];\n\nWiFiClient espClient;\n\nvoid callback(char *topic, byte *payload, unsigned int length) {\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n  for (int i = 0; i \u003c length; i++) {\n    Serial.print((char)payload[i]);\n  }\n  Serial.println();\n}\n\nPubSubClient client(espClient);\n\nvoid reconnect() {\n  // Loop until we're reconnected\n  while (!client.connected()) {\n    Serial.print(\"Attempting MQTT connection...\");\n    // Attempt to connect\n    if (client.connect(\"arduinoClient\")) {\n      Serial.println(\"connected\");\n      // Once connected, publish an announcement...\n      client.publish(\"connected\", \"Welcome to Jung's Factory\");\n      // ... and resubscribe\n      client.subscribe(\"connected\");\n    } else {\n      Serial.print(\"failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" try again in 5 seconds\");\n      // Wait 5 seconds before retrying\n      delay(5000);\n    }\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  client.setServer(server, 1883);\n  client.setCallback(callback);\n  setup_wifi();\n  // Allow the hardware to sort itself out\n  delay(1500);\n\n\n  Serial.println(\"SHT31 test\");\n  if (!sht31.begin(0x44)) {\n    Serial.println(\"Couldn't find SHT31\");\n    while (1) delay(1);\n  }\n\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    reconnect();\n  }\n\n  client.loop();\n  current_time = millis();\n\n  if (current_time - last_run \u003e= THREE_SECONDS) {\n    // save the last time you blinked the LED\n    last_run = current_time;\n\n    float t = sht31.readTemperature();\n    float h = sht31.readHumidity();\n\n    if (!isnan(t)) {  // check if 'is not a number'\n      sprintf(temp, \"%.2f\", t);\n      client.publish(\"mytopic/temp\", temp);\n      // Serial.print(\" Temperature: \");\n      // Serial.print(t);\n      // Serial.println();\n    }\n\n    if (!isnan(h)) {  // check if 'is not a number'\n      sprintf(humi, \"%.2f\", h);\n      client.publish(\"mytopic/humi\", humi);\n      // Serial.print(\" Humidity: \");\n      // Serial.print(h);\n      // Serial.println();\n    }\n  }\n}\n\n\n  void setup_wifi() {\n    delay(10);\n    // We start by connecting to a WiFi network\n    Serial.println();\n    Serial.print(\"Connecting to \");\n    Serial.println(wifi_ssid);\n    WiFi.begin(wifi_ssid, wifi_password);\n\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    }\n\n    Serial.println(\"\");\n    Serial.println(\"WiFi connected\");\n    Serial.println(\"IP address: \");\n    Serial.println(WiFi.localIP());\n  }\n````\n\n---\n\npython 샘플 코드\n\n````python\nimport paho.mqtt.client as mqtt\n\n# MQTT broker 정보\nbroker_address = \"192.168.10.101\"\nport = 1883\n\n# Subscriber 콜백 함수\ndef on_message(client, userdata, message):\n    print(f\"Received message: {message.topic} {str(message.payload.decode('utf-8'))}\")\n\n# MQTT client 생성\nclient = mqtt.Client()\n\n# Subscriber 콜백 함수 등록\nclient.on_message = on_message\n\n# MQTT broker 연결\nclient.connect(broker_address, port=port)\n\n# 구독할 토픽\ntemp = \"mytopic/temp\"\nhumi = \"mytopic/humi\"\n\n# MQTT client에 토픽 구독 요청\nclient.subscribe(temp)\nclient.subscribe(humi)\n\n# Subscriber 유지\nclient.loop_forever()\n\n\n````\n","lastmodified":"2023-06-10T09:18:39.908132822+09:00","tags":[]},"/Publish/Hello-World":{"title":"Hello World","content":"\n---\n\n## title : \"Hello World\"\n","lastmodified":"2023-06-10T09:18:39.91069444+09:00","tags":[]},"/_DelSyncFiles/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/Hithere-app":{"title":"Hithere - app","content":"\n---\n\n# firebase 연결 + google login\n\n[유튜브 참고 영상](https://youtu.be/Y0IKGgBM8zo)\n\nCreate flutter project\n\n````shell\n# flutter create --org \u003corganization\u003e \u003cproject name\u003e\n$ flutter create --org com.hithere hithere_login\n````\n\n[Fire base](https://console.firebase.google.com/?hl=ko) 접속 후 프로젝트 추가\n\n프로젝트 생성 후\n-\u003e \n\n### 플러터 앱에 파이어 베이스 추가\n\n````\nFirebase Cli 설치 및 로그인\nFlutter sdk 설치\nFlutter create\n````\n\n````shell\n$ dart pub global activate flutterfire_cli\n\n# flutterfire configure --project= \u003cproject name\u003e\n$ flutterfire configure --project=hithere-login-4b114\n````\n\n안드로이드와 ios 체크\n\n### 안드로이드 앱에 파이어 베이스 추가\n\n\n\nandroid/app/build.gradle -\u003e applicationId 가 패키지 이름이다.\n\n[Keytool 사용 방법](https://developers.google.com/android/guides/client-auth?hl=ko) 을 통해 해시값 가져오기\ngoogle-services.json 다운로드 후 android/app/ 폴더에 덮어쓰기\n순서대로 Firebase SDK 추가\n\nandroid/app/build.gradle 파일\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n    minSdkVersion flutter.minSdkVersion  \n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\nminSdkversion 값 19로 변경\nmultiDexEnabled true -\u003e 추가\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n\tmultiDexEnabled true\n    minSdkVersion 19\n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\n### flutter package 설치\n\n\\\u003c프로젝트명\u003e/pubspec.yaml\n\n````yaml\ndepemdencies:\n...\nfirebase_auth: ^4.2.9  \nfirebase_core: ^2.6.1  \ngoogle_sign_in: ^6.0.2\n````\n\n추가후 \n\n````shell\nflutter pub get\n````\n\n23.03.14 실행확인\n\n---\n\n# Facebook login\n\n[유튜브 참고 영상 링크](https://youtu.be/tPpFp9LFGgE)\nfacebook developer 에서 앱만들기\n설정 -\u003e 기본설정 탭\n앱 ID , 앱 시크릿 코드 파이어 베이스에 붙여넣기\n\n파이어베이스에서 리디렉션 URI 를 페이스북에 붙여넣기\n\n\n페이스북 빠른시작 탭에서 앱 설정\n\n순서대로 진행\n\n6. 리소스 및 메니페스트 수정 탭 에서\n   선택 사항) [광고 ID 권한](https://developers.facebook.com/docs/android/getting-started#ad-id-permissions)을 옵트아웃하려면 `uses-permission` 요소를 `application` 요소 뒤의 매니페스트에 추가합니다. \n   -\u003e 추가 안함\n\n### flutter package 설치\n\n\\\u003c프로젝트명\u003e/pubspec.yaml\n\n````yaml\ndepemdencies:\n...\nflutter_facebook_auth: ^3.5.0\n````\n\n````shell\nflutter pub get\n````\n\nfacebook auth 버전때문에 minSdkVersion 을 21로 변경\n\n````gradle\n...\ndefaultConfig {  \n    applicationId \"com.hithere.hithere_login\"  \n\tmultiDexEnabled true\n    minSdkVersion 21\n    targetSdkVersion flutter.targetSdkVersion  \n    versionCode flutterVersionCode.toInteger()  \n    versionName flutterVersionName  \n}\n...\n````\n\n# Graphql  사용하기\n\n````\ndependencies:\n\tgraphql: ^5.1.3\n````\n","lastmodified":"2023-06-10T09:18:39.914409593+09:00","tags":[]},"/_DelSyncFiles/Daily/2023-05-06":{"title":"2023-05-06","content":"\n---\n\n# 키워드\n\n \u003e \n \u003e ## \\#깨닳음 #TIL\n\n---\n\n# 간단한 메모\n\n어떤일을 실제로 하는것보다, 하기싫은마음을 이겨내는게 더 힘이 들때가 많아.\n하기좋은 일만 할 수 없다는것도 사실이지만 하기싫은일을 계속 붙들고 있으면 괜한 힘을 , 에너지를 계속 쓰는듯\n\n---\n\n# TIL\n\n[MQTT 사용하기](../../%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3/MQTT%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5.md)\n\n---\n\n# Time Log\n\n|시간|내용|\n|:-----|------|\n|12:00|기상|\n|15:00|mqtt 테스트 환경 만들기|\n|19:00|저녁|\n|20:30|아이클라우드 동기화 완료|\n|||\n|||\n","lastmodified":"2023-06-10T09:18:39.911924935+09:00","tags":[]},"/_DelSyncFiles/Daily/2023-05-07":{"title":"2023-05-07","content":"\n# 제목 : ****\n\n# 키워드\n\n \u003e \n \u003e ## \n\n---\n\n# 간단한 메모\n\n---\n\n# TIL\n\n---\n\n# TimeLog\n\n|시간|내용|\n|:-----|------|\n|||\n","lastmodified":"2023-06-10T09:18:39.909577615+09:00","tags":[]},"/_DelSyncFiles/Template/Daily-note":{"title":"Daily note","content":"\n# 제목 : ****\n\n# 키워드\n\n \u003e \n \u003e ## \n\n---\n\n# 간단한 메모\n\n---\n\n# TIL\n\n---\n\n# TimeLog\n\n|시간|내용|\n|:-----|------|\n|||\n","lastmodified":"2023-06-10T09:18:39.90852425+09:00","tags":[]},"/_DelSyncFiles/Template/PiCam":{"title":"PiCam","content":"\n---\n\n### 준비물\n\n||||\n|::|::|::|\n|카메라|점퍼|RPi|\n|\u003cbr\u003e|||\n\n---\n\n### 카메라 조립 및 환경 설정\n\n\n\n","lastmodified":"2023-06-10T09:18:39.920520735+09:00","tags":[]}}